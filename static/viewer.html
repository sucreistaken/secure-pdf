<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PDF Viewer</title>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>

    <style>
        /* Microsoft Edge / Dark Theme */
        :root {
            --bg-primary: #1f1f1f;
            --bg-secondary: #2d2d2d;
            --bg-tertiary: #3d3d3d;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --accent: #0078d4;
            --accent-hover: #1a86d9;
            --border-color: #404040;
            --toolbar-height: 48px;
            --sidebar-width: 200px;
            --toolbar-height-mobile: 44px;
            --bottom-bar-height: 52px;
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            background: var(--bg-primary);
            font-family: "Segoe UI", system-ui, sans-serif;
            font-size: 14px;
            overflow: hidden;
            color: var(--text-primary);
            /* Security: prevent text selection globally */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Prevent scroll chaining out of iframe */
            overscroll-behavior: contain;
        }

        /* Print Protection - hide everything when printing */
        @media print {

            html,
            body,
            #viewerContainer,
            #viewer,
            .pdfViewer,
            .page {
                display: none !important;
                visibility: hidden !important;
            }

            body::before {
                content: 'Bu içeriğin yazdırılması engellenmiştir.' !important;
                display: block !important;
                font-size: 24px;
                padding: 50px;
                text-align: center;
                color: #666;
            }
        }

        /* Loading Spinner Animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        .dropzone svg.spin {
            fill: var(--accent);
        }

        /* Toolbar - Edge Style */
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: var(--toolbar-height);
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 12px;
            gap: 4px;
            z-index: 100;
        }

        .toolbarGroup {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .toolbarBtn {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.1s;
        }

        .toolbarBtn:hover {
            background: var(--bg-tertiary);
        }

        .toolbarBtn.active {
            background: var(--accent);
        }

        .toolbarBtn svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .separator {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 8px;
        }

        /* Enhanced Tooltips */
        .toolbarBtn {
            position: relative;
        }

        .toolbarBtn::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a1a1a;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            margin-top: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .toolbarBtn::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-bottom-color: #1a1a1a;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1001;
            margin-top: -4px;
        }

        .toolbarBtn:hover::after,
        .toolbarBtn:hover::before {
            opacity: 1;
            visibility: visible;
        }

        .toolbarBtn .shortcut {
            display: inline;
            opacity: 0.6;
            margin-left: 8px;
            padding: 2px 5px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 3px;
            font-size: 10px;
        }

        /* Context Menu */
        .contextMenu {
            position: fixed;
            background: #2d2d2d;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 6px 0;
            min-width: 180px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            display: none;
        }

        .contextMenu.visible {
            display: block;
        }

        .contextMenuItem {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 12px;
            color: var(--text-primary);
            font-size: 13px;
            transition: background 0.1s;
        }

        .contextMenuItem:hover {
            background: var(--bg-tertiary);
        }

        .contextMenuItem svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
            opacity: 0.8;
        }

        .contextMenuItem .shortcutHint {
            margin-left: auto;
            opacity: 0.5;
            font-size: 11px;
        }

        .contextMenuDivider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
        }

        /* Tool Dropdown Panel - Microsoft Edge Style */
        .toolDropdown {
            position: absolute;
            top: calc(var(--toolbar-height) + 4px);
            background: #2d2d2d;
            border-radius: 8px;
            padding: 16px;
            min-width: 240px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: none;
            z-index: 200;
        }

        .toolDropdown.visible {
            display: block;
        }

        .dropdownSection {
            margin-bottom: 16px;
        }

        .dropdownSection:last-child {
            margin-bottom: 0;
        }

        .dropdownLabel {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .dropdownLabel svg {
            width: 14px;
            height: 14px;
            fill: var(--text-secondary);
        }

        /* Color Grid */
        .colorGrid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .colorDot {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.1s;
        }

        .colorDot:hover {
            transform: scale(1.1);
        }

        .colorDot.active {
            border-color: var(--text-primary);
        }

        /* Stroke Preview Wave */
        .strokePreview {
            height: 50px;
            background: #1f1f1f;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .strokePreview svg {
            width: 100%;
            height: 100%;
        }

        /* Thickness Slider */
        .thicknessSlider {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .thicknessSlider input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: #555;
            border-radius: 2px;
            outline: none;
        }

        .thicknessSlider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .thicknessSlider input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .thicknessLabels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Tool button with dropdown arrow */
        .toolbarBtnWithDropdown {
            position: relative;
            display: flex;
            align-items: center;
        }

        .toolbarBtnWithDropdown .toolbarBtn {
            border-radius: 4px 0 0 4px;
        }

        .dropdownArrow {
            width: 20px;
            height: 36px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            border-radius: 0 4px 4px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dropdownArrow:hover {
            background: var(--bg-tertiary);
        }

        .toolbarBtnWithDropdown.active .toolbarBtn,
        .toolbarBtnWithDropdown.active .dropdownArrow {
            background: var(--accent);
        }

        .dropdownArrow svg {
            width: 12px;
            height: 12px;
            fill: currentColor;
        }

        /* Overflow Menu Items */
        .overflowItem {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            width: 100%;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
        }

        .overflowItem:hover {
            background: var(--bg-tertiary);
        }

        .overflowItem svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
            flex-shrink: 0;
        }

        .overflowItem.active {
            color: var(--accent);
        }

        .overflowDivider {
            height: 1px;
            background: var(--border-color);
            margin: 6px 0;
        }

        /* Overflow: visible on all screens, originals hidden */
        #overflowWrapper {
            display: flex;
        }

        .overflowSep {
            display: block;
        }

        /* Hide rotate, sepia and their separators (children 3-8 of view group) */
        .toolbarGroup:nth-child(5)> :nth-child(3),
        .toolbarGroup:nth-child(5)> :nth-child(4),
        .toolbarGroup:nth-child(5)> :nth-child(5),
        .toolbarGroup:nth-child(5)> :nth-child(6),
        .toolbarGroup:nth-child(5)> :nth-child(7),
        .toolbarGroup:nth-child(5)> :nth-child(8) {
            display: none !important;
        }

        /* Shape Grid */
        .shapeGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .shapeBtn {
            width: 48px;
            height: 48px;
            background: #1f1f1f;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            transition: border-color 0.1s, background 0.1s;
        }

        .shapeBtn:hover {
            background: #3d3d3d;
        }

        .shapeBtn.active {
            border-color: var(--accent);
            background: #3d3d3d;
        }

        .shapeBtn svg {
            width: 28px;
            height: 28px;
        }

        /* Page Info */
        .pageInfo {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        #pageInput {
            width: 40px;
            height: 28px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            text-align: center;
            font-size: 13px;
        }

        #pageCount {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Sidebar - Thumbnails */
        #sidebar {
            position: fixed;
            top: var(--toolbar-height);
            left: 0;
            bottom: 0;
            width: var(--sidebar-width);
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            display: none;
            z-index: 50;
        }

        #sidebar.open {
            display: block;
        }

        .sidebarHeader {
            padding: 12px 16px;
            font-size: 13px;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .closeBtn {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
        }

        #thumbnailContainer {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .thumbnail {
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            padding: 4px;
            transition: border-color 0.15s;
        }

        .thumbnail:hover {
            border-color: var(--accent);
        }

        .thumbnail.active {
            border-color: var(--accent);
        }

        .thumbnail canvas {
            width: 100%;
            display: block;
        }

        .thumbnailNum {
            text-align: center;
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Viewer Container */
        #viewerContainer {
            position: fixed;
            top: var(--toolbar-height);
            left: 0;
            right: 0;
            bottom: 0;
            overflow: auto;
            background: #525659;
            z-index: 1;
            /* Prevent scroll chaining to parent/iframe on touch devices */
            overscroll-behavior: contain;
            -webkit-overflow-scrolling: touch;
        }

        #viewerContainer.withSidebar {
            left: var(--sidebar-width);
        }

        .pdfViewer .page {
            margin: 8px auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            position: relative;
            transition: filter 0.3s ease;
        }

        /* Sepia Reading Mode */
        .pdfViewer.sepia .page canvas {
            filter: sepia(40%) brightness(0.95) contrast(0.9);
        }

        .pdfViewer.sepia .page {
            background: #f4ecd8 !important;
        }

        #viewerContainer.sepia {
            background: #d4c9a8;
        }

        /* Annotation Layer */
        .annotationLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .annotationLayer.active {
            pointer-events: auto;
            cursor: crosshair;
        }

        .annotationLayer path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Select tool cursor */
        .annotationLayer.select-mode {
            cursor: default;
        }

        .annotationLayer.select-mode path,
        .annotationLayer.select-mode rect,
        .annotationLayer.select-mode ellipse,
        .annotationLayer.select-mode line,
        .annotationLayer.select-mode text {
            cursor: grab;
            pointer-events: all;
            transition: transform 0.1s ease, opacity 0.1s ease;
        }

        /* Invisible hit area for easier selection */
        .annotationLayer.select-mode path,
        .annotationLayer.select-mode line {
            stroke-linecap: round;
        }

        .annotationLayer.select-mode path:hover,
        .annotationLayer.select-mode rect:hover,
        .annotationLayer.select-mode ellipse:hover,
        .annotationLayer.select-mode line:hover,
        .annotationLayer.select-mode text:hover {
            opacity: 0.8;
            cursor: grab;
        }

        /* Selected annotation element - use filter for SVG compatibility */
        .annotation-selected {
            filter: drop-shadow(0 0 4px #0078d4) drop-shadow(0 0 8px rgba(0, 120, 212, 0.6)) !important;
            opacity: 1 !important;
        }

        /* Marquee selection rectangle */
        .annotationLayer .marquee-rect {
            fill: rgba(0, 120, 212, 0.1) !important;
            stroke: #0078d4 !important;
            stroke-width: 1 !important;
            stroke-dasharray: 4 2 !important;
            pointer-events: none !important;
            cursor: default !important;
            opacity: 1 !important;
            filter: none !important;
            transition: none !important;
        }

        /* Multi-selected annotations */
        .annotation-multi-selected {
            filter: drop-shadow(0 0 3px #0078d4) drop-shadow(0 0 6px rgba(0, 120, 212, 0.4)) !important;
            opacity: 0.9 !important;
        }

        /* Touch feedback */
        .annotation-dragging {
            opacity: 0.6;
            cursor: grabbing !important;
            filter: drop-shadow(0 4px 12px rgba(0, 120, 212, 0.5));
        }

        /* Tablet/Touch optimizations for select mode */
        @media (pointer: coarse),
        (max-width: 1024px) {

            .annotationLayer.select-mode path,
            .annotationLayer.select-mode rect,
            .annotationLayer.select-mode ellipse,
            .annotationLayer.select-mode line,
            .annotationLayer.select-mode text {
                /* Ensure touch-friendly interaction */
                cursor: pointer;
            }

            /* Bigger toolbar buttons for touch */
            .toolbarBtn {
                width: 44px;
                height: 44px;
                min-width: 44px;
            }
        }

        /* Touch selection ring animation */
        @keyframes selectionPulse {
            0% {
                outline-color: rgba(0, 120, 212, 1);
            }

            50% {
                outline-color: rgba(0, 120, 212, 0.5);
            }

            100% {
                outline-color: rgba(0, 120, 212, 1);
            }
        }

        .annotation-selected.just-selected {
            animation: selectionPulse 0.6s ease-out;
        }

        /* Move handle for touch devices */
        .annotation-move-handle {
            position: absolute;
            width: 36px;
            height: 36px;
            background: rgba(0, 120, 212, 0.9);
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            cursor: grab;
            z-index: 100;
            touch-action: none;
        }

        .annotation-move-handle svg {
            width: 20px;
            height: 20px;
            fill: white;
        }

        @media (pointer: coarse) {
            .annotation-move-handle {
                display: flex;
            }
        }

        /* Ghost element while dragging */
        .annotation-ghost {
            opacity: 0.3;
            pointer-events: none;
        }

        /* Selection toolbar for touch - action buttons */
        .selection-toolbar {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: linear-gradient(135deg, #363636 0%, #2d2d2d 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.05);
            z-index: 2000;
            opacity: 0;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.2s ease;
            pointer-events: none;
        }

        .selection-toolbar.visible {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .selection-toolbar::before {
            content: 'Seçili Öğe';
            position: absolute;
            top: -28px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .selection-toolbar button {
            width: 52px;
            height: 52px;
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.15s ease;
            position: relative;
        }

        .selection-toolbar button:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
        }

        .selection-toolbar button:active {
            transform: translateY(0);
            background: rgba(255, 255, 255, 0.2);
        }

        .selection-toolbar button.delete {
            background: rgba(196, 43, 28, 0.8);
        }

        .selection-toolbar button.delete:hover {
            background: #e03e2f;
            transform: translateY(-2px);
        }

        .selection-toolbar button svg {
            width: 22px;
            height: 22px;
            fill: currentColor;
        }

        .selection-toolbar button span {
            font-size: 9px;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Toast notification for copy/paste */
        .toast-notification {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: #323232;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 3000;
            animation: toastIn 0.3s ease, toastOut 0.3s ease 1.7s forwards;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        @keyframes toastOut {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }

            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px);
            }
        }

        /* Text Selection Highlight */
        .textHighlight {
            position: absolute;
            pointer-events: none;
            border-radius: 2px;
        }

        /* Selection Popup Button */
        .highlightPopup {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 6px;
            display: flex;
            gap: 4px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            z-index: 500;
        }

        .highlightPopup button {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .highlightPopup button:hover {
            transform: scale(1.15);
        }

        /* Upload Overlay */
        #uploadOverlay {
            position: fixed;
            top: var(--toolbar-height);
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 40;
        }

        .dropzone {
            width: 400px;
            padding: 60px 40px;
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dropzone:hover {
            border-color: var(--accent);
            background: var(--bg-tertiary);
        }

        .dropzone svg {
            width: 64px;
            height: 64px;
            fill: var(--text-secondary);
            margin-bottom: 16px;
        }

        .dropzone h2 {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .dropzone p {
            color: var(--text-secondary);
            font-size: 13px;
        }

        /* Inline Text Editor */
        .textEditorOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
        }

        .textEditorBox {
            position: absolute;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 4px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            max-width: 400px;
        }

        .textEditorInput {
            padding: 12px 16px;
            font-size: 14px;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #333;
            outline: none;
            min-height: 40px;
            word-wrap: break-word;
        }

        .textEditorInput:empty:before {
            content: 'Buraya yazmaya başla...';
            color: #999;
        }

        .textEditorToolbar {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border-top: 1px solid #e0e0e0;
            background: #f5f5f5;
            flex-wrap: wrap;
        }

        .textEditorColors {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .textEditorSizeGroup {
            display: flex;
            align-items: center;
            gap: 2px;
            margin-left: 4px;
        }

        .textEditorSizeLabel {
            font-size: 12px;
            font-weight: 600;
            color: #333;
            min-width: 24px;
            text-align: center;
            user-select: none;
        }

        .textEditorBtn {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-size: 12px;
            font-weight: 600;
        }

        .textEditorBtn:hover {
            background: #e0e0e0;
        }

        .textEditorBtn.delete {
            color: #d32f2f;
            margin-left: auto;
        }

        .textEditorColorDot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            flex-shrink: 0;
        }

        .textEditorColorDot:hover {
            transform: scale(1.15);
        }

        .textEditorColorDot.active {
            border-color: var(--accent);
        }

        /* Draggable text annotations */
        .annotationLayer svg text {
            cursor: move;
            user-select: none;
        }

        .annotationLayer svg text.dragging {
            opacity: 0.7;
        }

        .hidden {
            display: none !important;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* ==========================================
           BOTTOM TOOLBAR (Mobile Only)
           ========================================== */
        #bottomToolbar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            z-index: 100;
            padding: 0 8px;
            padding-bottom: var(--safe-area-bottom);
        }

        .bottomToolbarInner {
            display: flex;
            align-items: center;
            gap: 2px;
            height: var(--bottom-bar-height);
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .bottomToolbarInner::-webkit-scrollbar {
            display: none;
        }

        /* Dropdown backdrop overlay */
        #dropdownBackdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 250;
        }

        #dropdownBackdrop.visible {
            display: block;
        }

        /* Bottom sheet drag handle */
        .bottomSheetHandle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 8px auto 4px;
        }

        /* ==========================================
           MOBILE BREAKPOINT (max-width: 599px)
           ========================================== */
        @media (max-width: 599px) {

            /* Top toolbar - compact mobile layout */
            #toolbar {
                height: calc(var(--toolbar-height-mobile) + var(--safe-area-top));
                padding-top: var(--safe-area-top);
                padding-left: calc(8px + var(--safe-area-left));
                padding-right: calc(8px + var(--safe-area-right));
                gap: 2px;
            }

            /* Hide annotation tools from top bar on mobile (they go to bottom bar) */
            #toolbar>.toolbarGroup:nth-child(3) {
                display: none;
            }

            /* Hide separators adjacent to hidden group */
            #toolbar>.separator:nth-child(2),
            #toolbar>.separator:nth-child(4) {
                display: none;
            }

            /* Show bottom toolbar */
            #bottomToolbar {
                display: block;
            }

            /* Viewer container adjusted for mobile toolbars */
            #viewerContainer {
                top: calc(var(--toolbar-height-mobile) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            /* Upload overlay adjusted */
            #uploadOverlay {
                top: calc(var(--toolbar-height-mobile) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            /* Sidebar - full width overlay on mobile */
            #sidebar {
                width: 100%;
                z-index: 150;
                top: calc(var(--toolbar-height-mobile) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            #viewerContainer.withSidebar {
                left: 0;
            }

            /* Dropdowns become bottom sheets on mobile */
            .toolDropdown {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                border-radius: 16px 16px 0 0;
                padding: 8px 16px calc(16px + var(--safe-area-bottom));
                max-height: 60vh;
                overflow-y: auto;
                z-index: 300;
                transform: translateY(100%);
                transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
                display: block !important;
                min-width: unset;
                box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.4);
                pointer-events: none;
            }

            .toolDropdown.visible {
                transform: translateY(0);
                pointer-events: auto;
            }

            /* Responsive dropzone */
            .dropzone {
                width: 90%;
                padding: 40px 20px;
            }

            .dropzone svg {
                width: 48px;
                height: 48px;
            }

            .dropzone h2 {
                font-size: 16px;
            }

            /* Text editor bounds */
            .textEditorBox {
                max-width: calc(100vw - 32px);
                max-height: calc(100vh - 120px);
            }

            /* Selection toolbar above bottom bar */
            .selection-toolbar {
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom) + 12px);
            }

            /* Toast above bottom bar */
            .toast-notification {
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom) + 16px);
            }

            /* Page info compact */
            .pageInfo {
                margin-left: auto;
                gap: 4px;
            }

            #pageInput {
                width: 32px;
                font-size: 12px;
            }

            #pageCount {
                font-size: 12px;
            }

            /* Hide tooltips on mobile (no hover) */
            .toolbarBtn::after,
            .toolbarBtn::before {
                display: none;
            }
        }

        /* ==========================================
           TABLET BREAKPOINT (600px - 1024px)
           ========================================== */

        /* --- Tablet shared (both orientations) --- */
        @media (min-width: 600px) and (max-width: 1024px) {

            /* Scrollable toolbar */
            #toolbar {
                overflow-x: auto;
                overflow-y: hidden;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }

            #toolbar::-webkit-scrollbar {
                display: none;
            }

            /* Hide tooltips on touch tablets */
            .toolbarBtn::after,
            .toolbarBtn::before {
                display: none;
            }

            /* Safe area insets for modern tablets */
            #toolbar {
                padding-top: var(--safe-area-top);
                padding-left: calc(12px + var(--safe-area-left));
                padding-right: calc(12px + var(--safe-area-right));
            }

            /* Text editor bounds check */
            .textEditorBox {
                max-width: calc(100vw - 48px);
                max-height: calc(100vh - 140px);
            }

            /* Dropzone slightly smaller */
            .dropzone {
                width: 70%;
            }
        }

        /* --- Tablet PORTRAIT --- */
        @media (min-width: 600px) and (max-width: 1024px) and (orientation: portrait) {

            /* Top toolbar compact — height includes safe area (like mobile) */
            #toolbar {
                height: calc(var(--toolbar-height) + var(--safe-area-top));
                gap: 2px;
            }

            /* Hide annotation tools group from top bar (CSS hides, JS moves) */
            #toolbar>.toolbarGroup:nth-child(3) {
                display: none;
            }

            #toolbar>.separator:nth-child(2),
            #toolbar>.separator:nth-child(4) {
                display: none;
            }

            /* Show bottom toolbar */
            #bottomToolbar {
                display: block;
            }

            /* Viewer container adjusted for both toolbars */
            #viewerContainer {
                top: calc(var(--toolbar-height) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            #uploadOverlay {
                top: calc(var(--toolbar-height) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            /* Sidebar as overlay (don't push content) */
            #sidebar {
                width: 280px;
                z-index: 150;
                top: calc(var(--toolbar-height) + var(--safe-area-top));
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom));
            }

            #viewerContainer.withSidebar {
                left: 0;
            }

            /* Dropdowns become bottom sheets */
            .toolDropdown {
                position: fixed !important;
                bottom: 0 !important;
                left: 0 !important;
                right: 0 !important;
                top: auto !important;
                border-radius: 16px 16px 0 0;
                padding: 12px 20px calc(16px + var(--safe-area-bottom));
                max-height: 55vh;
                overflow-y: auto;
                z-index: 300;
                transform: translateY(100%);
                transition: transform 0.3s cubic-bezier(0.32, 0.72, 0, 1);
                display: block !important;
                min-width: unset;
                box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.4);
                pointer-events: none;
            }

            .toolDropdown.visible {
                transform: translateY(0);
                pointer-events: auto;
            }

            /* Selection toolbar & toast above bottom bar */
            .selection-toolbar {
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom) + 12px);
            }

            .toast-notification {
                bottom: calc(var(--bottom-bar-height) + var(--safe-area-bottom) + 16px);
            }
        }

        /* --- Tablet LANDSCAPE --- */
        @media (min-width: 600px) and (max-width: 1024px) and (orientation: landscape) {

            /* Toolbar stays single row, compact gaps */
            #toolbar {
                gap: 2px;
            }

            .separator {
                margin: 0 4px;
            }

            /* Sidebar narrower to save space */
            #sidebar {
                width: 180px;
            }

            #viewerContainer.withSidebar {
                left: 180px;
            }

            /* Dropdowns get wider min-width */
            .toolDropdown {
                min-width: 280px;
            }
        }

        /* ==========================================
           TOUCH-FRIENDLY SIZES (pointer: coarse)
           ========================================== */
        @media (pointer: coarse) {
            .thicknessSlider input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            .thicknessSlider input[type="range"]::-moz-range-thumb {
                width: 24px;
                height: 24px;
            }

            .colorDot {
                width: 36px;
                height: 36px;
            }

            .shapeBtn {
                width: 56px;
                height: 56px;
            }

            /* Let our JS handle pinch-to-zoom, but allow browser pan-y for scroll */
            #viewerContainer {
                touch-action: pan-x pan-y;
            }
        }
    </style>
</head>

<body>
    <!-- Toolbar -->
    <div id="toolbar">
        <div class="toolbarGroup">
            <button class="toolbarBtn" id="sidebarBtn" data-tooltip="İçindekiler (S)">
                <svg viewBox="0 0 24 24">
                    <path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" />
                </svg>
            </button>
        </div>



        <div class="separator"></div>

        <div class="toolbarGroup">
            <!-- Highlighter with dropdown -->
            <div class="toolbarBtnWithDropdown" id="highlightWrapper">
                <button class="toolbarBtn" id="highlightBtn" title="Vurgula">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 21h18v-2H3v2zM5 16h14l-3-10H8l-3 10zM9 8h6l1.5 5h-9L9 8z" opacity="0.7" />
                    </svg>
                </button>
                <button class="dropdownArrow" id="highlightArrow">
                    <svg viewBox="0 0 24 24">
                        <path d="M7 10l5 5 5-5z" />
                    </svg>
                </button>
                <!-- Highlighter Dropdown Panel -->
                <div class="toolDropdown" id="highlightDropdown">
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Renkler</div>
                        <div class="colorGrid" id="highlightColors">
                            <div class="colorDot active" style="background:#fff100" data-color="#fff100"></div>
                            <div class="colorDot" style="background:#16c60c" data-color="#16c60c"></div>
                            <div class="colorDot" style="background:#00b7c3" data-color="#00b7c3"></div>
                            <div class="colorDot" style="background:#0078d4" data-color="#0078d4"></div>
                            <div class="colorDot" style="background:#886ce4" data-color="#886ce4"></div>
                            <div class="colorDot" style="background:#e81224" data-color="#e81224"></div>
                        </div>
                    </div>
                    <div class="strokePreview" id="highlightPreview">
                        <svg viewBox="0 0 200 50" preserveAspectRatio="none">
                            <path id="highlightWave" d="M10,35 Q50,10 100,25 T190,25" fill="none" stroke="#fff100"
                                stroke-width="10" stroke-linecap="round" stroke-opacity="0.5" />
                        </svg>
                    </div>
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Kalınlık</div>
                        <div class="thicknessSlider">
                            <input type="range" id="highlightThickness" min="1" max="10" value="4">
                            <div class="thicknessLabels">
                                <span>İnce</span>
                                <span>Kalın</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pen/Draw with dropdown -->
            <div class="toolbarBtnWithDropdown" id="drawWrapper">
                <button class="toolbarBtn" id="drawBtn" title="Çiz">
                    <svg viewBox="0 0 24 24">
                        <path
                            d="M20.71 4.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83zM3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25z" />
                    </svg>
                </button>
                <button class="dropdownArrow" id="drawArrow">
                    <svg viewBox="0 0 24 24">
                        <path d="M7 10l5 5 5-5z" />
                    </svg>
                </button>
                <!-- Pen Dropdown Panel -->
                <div class="toolDropdown" id="drawDropdown">
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Renkler</div>
                        <div class="colorGrid" id="drawColors">
                            <div class="colorDot" style="background:#000000" data-color="#000000"></div>
                            <div class="colorDot" style="background:#ffffff" data-color="#ffffff"></div>
                            <div class="colorDot" style="background:#808080" data-color="#808080"></div>
                            <div class="colorDot" style="background:#c0c0c0" data-color="#c0c0c0"></div>
                            <div class="colorDot" style="background:#404040" data-color="#404040"></div>
                            <div class="colorDot" style="background:#f5f5dc" data-color="#f5f5dc"></div>
                            <div class="colorDot" style="background:#ff6b9d" data-color="#ff6b9d"></div>
                            <div class="colorDot active" style="background:#e81224" data-color="#e81224"></div>
                            <div class="colorDot" style="background:#ff8c00" data-color="#ff8c00"></div>
                            <div class="colorDot" style="background:#fff100" data-color="#fff100"></div>
                            <div class="colorDot" style="background:#ffd700" data-color="#ffd700"></div>
                            <div class="colorDot" style="background:#f5deb3" data-color="#f5deb3"></div>
                            <div class="colorDot" style="background:#16c60c" data-color="#16c60c"></div>
                            <div class="colorDot" style="background:#00ff00" data-color="#00ff00"></div>
                            <div class="colorDot" style="background:#008b8b" data-color="#008b8b"></div>
                            <div class="colorDot" style="background:#0078d4" data-color="#0078d4"></div>
                            <div class="colorDot" style="background:#00bfff" data-color="#00bfff"></div>
                            <div class="colorDot" style="background:#add8e6" data-color="#add8e6"></div>
                            <div class="colorDot" style="background:#9400d3" data-color="#9400d3"></div>
                            <div class="colorDot" style="background:#886ce4" data-color="#886ce4"></div>
                            <div class="colorDot" style="background:#dda0dd" data-color="#dda0dd"></div>
                            <div class="colorDot" style="background:#ffdab9" data-color="#ffdab9"></div>
                            <div class="colorDot" style="background:#d2691e" data-color="#d2691e"></div>
                            <div class="colorDot" style="background:#8b4513" data-color="#8b4513"></div>
                        </div>
                    </div>
                    <div class="strokePreview" id="drawPreview">
                        <svg viewBox="0 0 200 50" preserveAspectRatio="none">
                            <path id="drawWave" d="M10,35 Q50,10 100,25 T190,25" fill="none" stroke="#e81224"
                                stroke-width="3" stroke-linecap="round" />
                        </svg>
                    </div>
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Kalınlık</div>
                        <div class="thicknessSlider">
                            <input type="range" id="drawThickness" min="1" max="10" value="2">
                            <div class="thicknessLabels">
                                <span>İnce</span>
                                <span>Kalın</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <button class="toolbarBtn" id="eraserBtn" data-tooltip="Silgi (E)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 01-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0zM4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53-4.95-4.95-4.95 4.95z" />
                </svg>
            </button>
            <button class="toolbarBtn" id="selectBtn" data-tooltip="Seç/Taşı (V)">
                <svg viewBox="0 0 24 24">
                    <path d="M7 2l12 11.2-5.8.5 3.3 7.3-2.2 1-3.2-7.4L7 18.5V2z" />
                </svg>
            </button>

            <div class="separator"></div>

            <!-- Undo / Redo / Clear All -->
            <button class="toolbarBtn" id="undoBtn" data-tooltip="Geri Al (Ctrl+Z)" disabled>
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12.5 8c-2.65 0-5.05 1.04-6.83 2.73L2.5 7.5v9h9l-3.19-3.19c1.29-1.25 3.04-2.02 5-2.02 3.24 0 5.97 2.13 6.89 5.07l2.36-.78C21.19 11.79 17.22 8 12.5 8z" />
                </svg>
            </button>
            <button class="toolbarBtn" id="redoBtn" data-tooltip="Yinele (Ctrl+Y)" disabled>
                <svg viewBox="0 0 24 24">
                    <path
                        d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13.5 16.5h9v-9l-4.1 3.1z" />
                </svg>
            </button>
            <button class="toolbarBtn" id="clearAllBtn" data-tooltip="Tümünü Temizle">
                <svg viewBox="0 0 24 24">
                    <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                </svg>
            </button>

            <div class="separator"></div>

            <button class="toolbarBtn" id="textBtn" data-tooltip="Metin Ekle (T)">
                <svg viewBox="0 0 24 24">
                    <path d="M5 4v3h5.5v12h3V7H19V4H5z" />
                </svg>
            </button>

            <!-- Shapes Dropdown -->
            <div class="toolbarBtnWithDropdown" id="shapesWrapper">
                <button class="toolbarBtn" id="shapesBtn" title="Şekiller">
                    <svg viewBox="0 0 24 24">
                        <path d="M3 3h8v8H3V3zm10 0h8v8h-8V3zM3 13h8v8H3v-8zm13 0a5 5 0 110 10 5 5 0 010-10z" />
                    </svg>
                </button>
                <button class="dropdownArrow" id="shapesArrow">
                    <svg viewBox="0 0 24 24">
                        <path d="M7 10l5 5 5-5z" />
                    </svg>
                </button>
                <!-- Shapes Dropdown Panel -->
                <div class="toolDropdown" id="shapesDropdown">
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Şekil Seçin</div>
                        <div class="shapeGrid">
                            <button class="shapeBtn active" data-shape="rectangle" title="Dikdörtgen">
                                <svg viewBox="0 0 24 24">
                                    <rect x="3" y="5" width="18" height="14" fill="none" stroke="currentColor"
                                        stroke-width="2" />
                                </svg>
                            </button>
                            <button class="shapeBtn" data-shape="circle" title="Daire">
                                <svg viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" />
                                </svg>
                            </button>
                            <button class="shapeBtn" data-shape="line" title="Çizgi">
                                <svg viewBox="0 0 24 24">
                                    <line x1="4" y1="20" x2="20" y2="4" stroke="currentColor" stroke-width="2" />
                                </svg>
                            </button>
                            <button class="shapeBtn" data-shape="arrow" title="Ok">
                                <svg viewBox="0 0 24 24">
                                    <line x1="4" y1="20" x2="20" y2="4" stroke="currentColor" stroke-width="2" />
                                    <polyline points="10,4 20,4 20,14" fill="none" stroke="currentColor"
                                        stroke-width="2" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Renkler</div>
                        <div class="colorGrid" id="shapeColors">
                            <div class="colorDot active" style="background:#e81224" data-color="#e81224"></div>
                            <div class="colorDot" style="background:#0078d4" data-color="#0078d4"></div>
                            <div class="colorDot" style="background:#16c60c" data-color="#16c60c"></div>
                            <div class="colorDot" style="background:#fff100" data-color="#fff100"></div>
                            <div class="colorDot" style="background:#000000" data-color="#000000"></div>
                            <div class="colorDot" style="background:#ffffff" data-color="#ffffff"></div>
                        </div>
                    </div>
                    <div class="dropdownSection">
                        <div class="dropdownLabel">Kalınlık</div>
                        <div class="thicknessSlider">
                            <input type="range" id="shapeThickness" min="1" max="10" value="2">
                            <div class="thicknessLabels">
                                <span>İnce</span>
                                <span>Kalın</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="separator"></div>

        <div class="toolbarGroup">
            <button class="toolbarBtn" id="zoomOut" title="Uzaklaştır" disabled>
                <svg viewBox="0 0 24 24">
                    <path d="M19 13H5v-2h14v2z" />
                </svg>
            </button>
            <button class="toolbarBtn" id="zoomIn" title="Yakınlaştır" disabled>
                <svg viewBox="0 0 24 24">
                    <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                </svg>
            </button>

            <div class="separator"></div>

            <!-- Rotation Buttons -->
            <button class="toolbarBtn" id="rotateLeft" title="Sola Döndür" disabled>
                <svg viewBox="0 0 24 24">
                    <path
                        d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z" />
                </svg>
            </button>
            <button class="toolbarBtn" id="rotateRight" title="Sağa Döndür" disabled>
                <svg viewBox="0 0 24 24">
                    <path
                        d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z" />
                </svg>
            </button>

            <div class="separator"></div>

            <!-- Sepia Reading Mode -->
            <button class="toolbarBtn" id="sepiaBtn" title="Okuma Modu (Sepia)">
                <svg viewBox="0 0 24 24">
                    <path
                        d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
                </svg>
            </button>

            <div class="separator"></div>

            <!-- Fullscreen Toggle -->
            <button class="toolbarBtn" id="fullscreenBtn" data-tooltip="Tam Ekran (F)">
                <svg viewBox="0 0 24 24" id="fullscreenIcon">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" />
                </svg>
            </button>

            <div class="separator overflowSep"></div>

            <div class="toolbarBtnWithDropdown" id="overflowWrapper">
                <button class="toolbarBtn" id="overflowBtn" title="Daha Fazla">
                    <svg viewBox="0 0 24 24">
                        <circle cx="12" cy="5" r="2" />
                        <circle cx="12" cy="12" r="2" />
                        <circle cx="12" cy="19" r="2" />
                    </svg>
                </button>
                <div class="toolDropdown" id="overflowDropdown">
                    <button class="overflowItem" id="overflowRotateLeft">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M7.11 8.53L5.7 7.11C4.8 8.27 4.24 9.61 4.07 11h2.02c.14-.87.49-1.72 1.02-2.47zM6.09 13H4.07c.17 1.39.72 2.73 1.62 3.89l1.41-1.42c-.52-.75-.87-1.59-1.01-2.47zm1.01 5.32c1.16.9 2.51 1.44 3.9 1.61V17.9c-.87-.15-1.71-.49-2.46-1.03L7.1 18.32zM13 4.07V1L8.45 5.55 13 10V6.09c2.84.48 5 2.94 5 5.91s-2.16 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93s-3.05-7.44-7-7.93z" />
                        </svg>
                        <span>Sola Döndür</span>
                    </button>
                    <button class="overflowItem" id="overflowRotateRight">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M15.55 5.55L11 1v3.07C7.06 4.56 4 7.92 4 12s3.05 7.44 7 7.93v-2.02c-2.84-.48-5-2.94-5-5.91s2.16-5.43 5-5.91V10l4.55-4.45zM19.93 11c-.17-1.39-.72-2.73-1.62-3.89l-1.42 1.42c.54.75.88 1.6 1.02 2.47h2.02zM13 17.9v2.02c1.39-.17 2.74-.71 3.9-1.61l-1.44-1.44c-.75.54-1.59.89-2.46 1.03zm3.89-2.42l1.42 1.41c.9-1.16 1.45-2.5 1.62-3.89h-2.02c-.14.87-.48 1.72-1.02 2.48z" />
                        </svg>
                        <span>Sağa Döndür</span>
                    </button>
                    <div class="overflowDivider"></div>
                    <button class="overflowItem" id="overflowSepia">
                        <svg viewBox="0 0 24 24">
                            <path
                                d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
                        </svg>
                        <span>Okuma Modu</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="pageInfo">
            <input type="number" id="pageInput" value="1" min="1" disabled>
            <span id="pageCount">/ --</span>
        </div>
    </div>

    <!-- Bottom Toolbar (Mobile Only) -->
    <div id="bottomToolbar">
        <div class="bottomToolbarInner" id="bottomToolbarInner">
            <!-- Annotation tool buttons will be moved here on mobile via JS -->
        </div>
    </div>

    <!-- Dropdown Backdrop (Mobile) -->
    <div id="dropdownBackdrop"></div>

    <!-- Sidebar - Thumbnails -->
    <div id="sidebar">
        <div class="sidebarHeader">
            <span>İçindekiler</span>
            <button class="closeBtn" id="closeSidebar">×</button>
        </div>
        <div id="thumbnailContainer"></div>
    </div>

    <!-- Upload Overlay -->
    <div id="uploadOverlay">
        <div class="dropzone" id="dropzone">
            <svg viewBox="0 0 24 24">
                <path d="M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11z" />
            </svg>
            <h2>PDF Dosyası Aç</h2>
            <p>Sürükle bırak veya tıkla</p>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".pdf" hidden>

    <!-- PDF Viewer -->
    <div id="viewerContainer">
        <div id="viewer" class="pdfViewer"></div>
    </div>

    <script>
        // IIFE to prevent global access to pdfDoc, pdfViewer
        (function () {
            'use strict';

            // ============================================
            // CANVAS EXPORT PROTECTION
            // Block toDataURL/toBlob for PDF render canvas only
            // Allows: thumbnails, annotations, other canvases
            // ============================================
            const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
            const originalToBlob = HTMLCanvasElement.prototype.toBlob;

            HTMLCanvasElement.prototype.toDataURL = function () {
                // Block only main PDF page canvases (inside .page elements in #viewerContainer)
                if (this.closest && this.closest('.page') && this.closest('#viewerContainer')) {
                    console.warn('[Security] Canvas toDataURL blocked for PDF page');
                    return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';  // 1x1 transparent
                }
                return originalToDataURL.apply(this, arguments);
            };

            HTMLCanvasElement.prototype.toBlob = function (callback) {
                // Block only main PDF page canvases
                if (this.closest && this.closest('.page') && this.closest('#viewerContainer')) {
                    console.warn('[Security] Canvas toBlob blocked for PDF page');
                    // Return empty blob
                    if (callback) callback(new Blob([], { type: 'image/png' }));
                    return;
                }
                return originalToBlob.apply(this, arguments);
            };

            pdfjsLib.GlobalWorkerOptions.workerSrc = '';

            // State - now private, not accessible from console
            let pdfDoc = null;
            let pdfViewer = null;
            let annotationMode = false;
            let currentTool = null; // null, 'pen', 'highlight', 'eraser'
            let currentColor = '#e81224';
            let currentWidth = 2;
            let isDrawing = false;
            let currentPath = null;
            let currentDrawingPage = null;

            // RAF throttle for smooth drawing performance
            let pathSegments = [];  // Buffer path segments
            let drawRAF = null;     // requestAnimationFrame ID

            // Annotation persistence - stores SVG innerHTML per page
            const annotationsStore = new Map();
            const annotationRotations = new Map(); // tracks rotation when annotations were saved

            // AbortControllers for annotation layer event listeners (cleanup on re-inject)
            const annotationAbortControllers = new Map();  // pageNum -> AbortController

            // Undo/Redo history stacks - per page
            const undoStacks = new Map();  // pageNum -> [svgInnerHTML, ...]
            const redoStacks = new Map();  // pageNum -> [svgInnerHTML, ...]
            const MAX_HISTORY = 30;

            // Store base dimensions (scale=1.0) for each page - ensures consistent coordinates
            const pageBaseDimensions = new Map();

            // Current SVG reference for drawing
            let currentSvg = null;

            // Elements
            const container = document.getElementById('viewerContainer');
            const uploadOverlay = document.getElementById('uploadOverlay');
            const fileInput = document.getElementById('fileInput');
            const sidebar = document.getElementById('sidebar');
            const thumbnailContainer = document.getElementById('thumbnailContainer');

            // Initialize PDFViewer
            const eventBus = new pdfjsViewer.EventBus();
            const linkService = new pdfjsViewer.PDFLinkService({ eventBus });

            pdfViewer = new pdfjsViewer.PDFViewer({
                container: container,
                eventBus: eventBus,
                linkService: linkService,
                removePageBorders: true,
                textLayerMode: 2
            });
            linkService.setViewer(pdfViewer);

            // Track first page render for queue system
            let firstPageRendered = false;
            eventBus.on('pagerendered', function (evt) {
                if (!firstPageRendered && evt.pageNumber === 1) {
                    firstPageRendered = true;
                    // Notify parent that PDF is fully rendered (for queue system)
                    if (window.parent && window.parent !== window) {
                        const config = window.PDF_SECURE_CONFIG || {};
                        window.parent.postMessage({ type: 'pdf-secure-ready', filename: config.filename }, window.location.origin);
                        console.log('[PDF-Secure] First page rendered, notifying parent');
                    }
                }
            });

            // File Handling
            document.getElementById('dropzone').onclick = () => fileInput.click();

            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) await loadPDF(file);
            };

            uploadOverlay.ondragover = (e) => e.preventDefault();
            uploadOverlay.ondrop = async (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file?.type === 'application/pdf') await loadPDF(file);
            };

            async function loadPDF(file) {
                uploadOverlay.classList.add('hidden');

                const data = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument({ data }).promise;

                pdfViewer.setDocument(pdfDoc);
                linkService.setDocument(pdfDoc);

                ['zoomIn', 'zoomOut', 'pageInput', 'rotateLeft', 'rotateRight'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });

                // Thumbnails will be generated on-demand when sidebar opens
            }

            // Load PDF from ArrayBuffer (for secure nonce-based loading)
            async function loadPDFFromBuffer(arrayBuffer) {
                uploadOverlay.classList.add('hidden');

                pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

                pdfViewer.setDocument(pdfDoc);
                linkService.setDocument(pdfDoc);

                ['zoomIn', 'zoomOut', 'pageInput', 'rotateLeft', 'rotateRight'].forEach(id => {
                    document.getElementById(id).disabled = false;
                });

                // Thumbnails will be generated on-demand when sidebar opens
            }

            // Partial XOR decoder - must match backend encoding
            function partialXorDecode(encodedData, keyBase64) {
                const key = Uint8Array.from(atob(keyBase64), c => c.charCodeAt(0));
                const data = new Uint8Array(encodedData);
                const keyLen = key.length;

                // Decrypt first 10KB fully
                const fullDecryptLen = Math.min(10240, data.length);
                for (let i = 0; i < fullDecryptLen; i++) {
                    data[i] = data[i] ^ key[i % keyLen];
                }

                // Decrypt every 50th byte after that
                for (let i = fullDecryptLen; i < data.length; i += 50) {
                    data[i] = data[i] ^ key[i % keyLen];
                }

                return data.buffer;
            }

            // Auto-load PDF if config is present (injected by NodeBB plugin)
            async function autoLoadSecurePDF() {
                if (!window.PDF_SECURE_CONFIG || !window.PDF_SECURE_CONFIG.filename) {
                    console.log('[PDF-Secure] No config found, showing file picker');
                    return;
                }

                const config = window.PDF_SECURE_CONFIG;
                console.log('[PDF-Secure] Auto-loading:', config.filename);

                // Show loading state
                const dropzone = document.getElementById('dropzone');
                if (dropzone) {
                    dropzone.innerHTML = `
                    <svg viewBox="0 0 24 24" class="spin">
                        <path d="M12 4V2A10 10 0 0 0 2 12h2a8 8 0 0 1 8-8z" />
                    </svg>
                    <h2>PDF Yükleniyor...</h2>
                    <p>${config.filename}</p>
                `;
                }

                try {
                    // ============================================
                    // SPA CACHE - Check if parent has cached buffer
                    // ============================================
                    let pdfBuffer = null;

                    if (window.parent && window.parent !== window) {
                        // Request cached buffer from parent
                        const cachePromise = new Promise((resolve) => {
                            const handler = (event) => {
                                if (event.data && event.data.type === 'pdf-secure-cache-response' && event.data.filename === config.filename) {
                                    window.removeEventListener('message', handler);
                                    resolve(event.data.buffer);
                                }
                            };
                            window.addEventListener('message', handler);

                            // Timeout after 100ms
                            setTimeout(() => {
                                window.removeEventListener('message', handler);
                                resolve(null);
                            }, 100);

                            window.parent.postMessage({ type: 'pdf-secure-cache-request', filename: config.filename }, window.location.origin);
                        });

                        pdfBuffer = await cachePromise;
                        if (pdfBuffer) {
                            console.log('[PDF-Secure] Using cached buffer');
                        }
                    }

                    // If no cache, fetch from server
                    if (!pdfBuffer) {
                        // Nonce and key are embedded in HTML config (not fetched from API)
                        const nonce = config.nonce;
                        const xorKey = config.dk;

                        // Fetch encrypted PDF binary
                        const pdfUrl = config.relativePath + '/api/v3/plugins/pdf-secure/pdf-data?nonce=' + encodeURIComponent(nonce);
                        const pdfRes = await fetch(pdfUrl, { credentials: 'same-origin' });

                        if (!pdfRes.ok) {
                            throw new Error('PDF yüklenemedi (' + pdfRes.status + ')');
                        }

                        const encodedBuffer = await pdfRes.arrayBuffer();
                        console.log('[PDF-Secure] Encrypted data received:', encodedBuffer.byteLength, 'bytes');

                        // Decode XOR encrypted data
                        if (xorKey) {
                            console.log('[PDF-Secure] Decoding XOR encrypted data...');
                            pdfBuffer = partialXorDecode(encodedBuffer, xorKey);
                        } else {
                            pdfBuffer = encodedBuffer;
                        }

                        // Send buffer to parent for caching
                        if (window.parent && window.parent !== window) {
                            // Clone buffer for parent (we keep original)
                            const bufferCopy = pdfBuffer.slice(0);
                            window.parent.postMessage({
                                type: 'pdf-secure-buffer',
                                filename: config.filename,
                                buffer: bufferCopy
                            }, window.location.origin, [bufferCopy]);  // Transferable
                        }
                    }

                    console.log('[PDF-Secure] PDF decoded successfully');

                    // Step 4: Load into viewer
                    await loadPDFFromBuffer(pdfBuffer);

                    // Step 5: Moved to pagerendered event for proper timing

                    // Step 6: Security - clear references to prevent extraction
                    pdfBuffer = null;

                    // Security: Delete config containing sensitive data (nonce, key)
                    delete window.PDF_SECURE_CONFIG;

                    // Security: Remove PDF.js globals to prevent console manipulation
                    delete window.pdfjsLib;
                    delete window.pdfjsViewer;

                    // Security: Block dangerous PDF.js methods
                    if (pdfDoc) {
                        pdfDoc.getData = function () {
                            console.warn('[Security] getData() is blocked');
                            return Promise.reject(new Error('Access denied'));
                        };
                        pdfDoc.saveDocument = function () {
                            console.warn('[Security] saveDocument() is blocked');
                            return Promise.reject(new Error('Access denied'));
                        };
                    }

                    console.log('[PDF-Secure] PDF fully loaded and ready');

                } catch (err) {
                    console.error('[PDF-Secure] Auto-load error:', err);

                    // Notify parent of error (prevents 60s queue hang)
                    if (window.parent && window.parent !== window) {
                        const config = window.PDF_SECURE_CONFIG || {};
                        window.parent.postMessage({
                            type: 'pdf-secure-ready',
                            filename: config.filename,
                            error: err.message
                        }, window.location.origin);
                    }

                    if (dropzone) {
                        dropzone.innerHTML = `
                        <svg viewBox="0 0 24 24" style="fill: #e81224;">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                        </svg>
                        <h2>Hata</h2>
                        <p>${err.message}</p>
                    `;
                    }
                }
            }

            // Run auto-load on page ready
            autoLoadSecurePDF();

            // Generate Thumbnails (deferred - only when sidebar opens)
            let thumbnailsGenerated = false;
            async function generateThumbnails() {
                if (thumbnailsGenerated) return;
                thumbnailsGenerated = true;
                thumbnailContainer.innerHTML = '';

                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale: 0.2 });

                    const canvas = document.createElement('canvas');
                    canvas.width = viewport.width;
                    canvas.height = viewport.height;

                    await page.render({
                        canvasContext: canvas.getContext('2d'),
                        viewport: viewport
                    }).promise;

                    const thumb = document.createElement('div');
                    thumb.className = 'thumbnail' + (i === 1 ? ' active' : '');
                    thumb.dataset.page = i;
                    thumb.innerHTML = `<div class="thumbnailNum">${i}</div>`;
                    thumb.insertBefore(canvas, thumb.firstChild);

                    thumb.onclick = () => {
                        pdfViewer.currentPageNumber = i;
                        document.querySelectorAll('.thumbnail').forEach(t => t.classList.remove('active'));
                        thumb.classList.add('active');
                    };

                    thumbnailContainer.appendChild(thumb);
                }
            }

            // Events
            eventBus.on('pagesinit', () => {
                pdfViewer.currentScaleValue = 'page-width';
                document.getElementById('pageCount').textContent = `/ ${pdfViewer.pagesCount}`;
            });

            eventBus.on('pagechanging', (evt) => {
                document.getElementById('pageInput').value = evt.pageNumber;
                // Update active thumbnail
                document.querySelectorAll('.thumbnail').forEach(t => {
                    t.classList.toggle('active', parseInt(t.dataset.page) === evt.pageNumber);
                });
                // Update undo/redo buttons for new page
                updateUndoRedoButtons();

                // Bug fix: Clear selection on page change (stale SVG reference)
                clearAnnotationSelection();

                // Bug fix: Reset drawing state on page change
                if (isDrawing && currentDrawingPage) {
                    saveAnnotations(currentDrawingPage);
                }
                isDrawing = false;
                currentPath = null;
                currentSvg = null;
                currentDrawingPage = null;
            });

            eventBus.on('pagerendered', (evt) => {
                injectAnnotationLayer(evt.pageNumber);

                // Rotation is handled natively by PDF.js via pagesRotation
            });

            // Page Navigation
            document.getElementById('pageInput').onchange = (e) => {
                const num = parseInt(e.target.value);
                if (num >= 1 && num <= pdfViewer.pagesCount) {
                    pdfViewer.currentPageNumber = num;
                }
            };

            // Zoom
            document.getElementById('zoomIn').onclick = () => pdfViewer.currentScale += 0.25;
            document.getElementById('zoomOut').onclick = () => pdfViewer.currentScale -= 0.25;

            // Sidebar toggle (deferred thumbnail generation)
            const sidebarEl = document.getElementById('sidebar');
            const sidebarBtnEl = document.getElementById('sidebarBtn');
            const closeSidebarBtn = document.getElementById('closeSidebar');

            sidebarBtnEl.onclick = () => {
                const isOpening = !sidebarEl.classList.contains('open');
                sidebarEl.classList.toggle('open');
                sidebarBtnEl.classList.toggle('active');
                container.classList.toggle('withSidebar', sidebarEl.classList.contains('open'));

                // Generate thumbnails on first open (deferred loading)
                if (isOpening && pdfDoc) {
                    generateThumbnails();
                }
            };

            closeSidebarBtn.onclick = () => {
                sidebarEl.classList.remove('open');
                sidebarBtnEl.classList.remove('active');
                container.classList.remove('withSidebar');
            };

            // Sepia Reading Mode
            let sepiaMode = false;
            document.getElementById('sepiaBtn').onclick = () => {
                sepiaMode = !sepiaMode;
                document.getElementById('viewer').classList.toggle('sepia', sepiaMode);
                container.classList.toggle('sepia', sepiaMode);
                document.getElementById('sepiaBtn').classList.toggle('active', sepiaMode);
            };

            // Page Rotation — uses PDF.js native rotation (re-renders at correct size & quality)
            function rotatePage(delta) {
                const current = pdfViewer.pagesRotation || 0;
                // Clear cached dimensions so they get recalculated with new rotation
                pageBaseDimensions.clear();
                pdfViewer.pagesRotation = (current + delta + 360) % 360;
            }

            document.getElementById('rotateLeft').onclick = () => rotatePage(-90);
            document.getElementById('rotateRight').onclick = () => rotatePage(90);




            // Tool settings - separate for each tool
            let highlightColor = '#fff100';
            let highlightWidth = 4;
            let drawColor = '#e81224';
            let drawWidth = 2;
            let shapeColor = '#e81224';
            let shapeWidth = 2;
            let currentShape = 'rectangle'; // rectangle, circle, line, arrow

            // Dropdown Panel Logic
            const highlightDropdown = document.getElementById('highlightDropdown');
            const drawDropdown = document.getElementById('drawDropdown');
            const shapesDropdown = document.getElementById('shapesDropdown');
            const highlightWrapper = document.getElementById('highlightWrapper');
            const drawWrapper = document.getElementById('drawWrapper');
            const shapesWrapper = document.getElementById('shapesWrapper');

            const dropdownBackdrop = document.getElementById('dropdownBackdrop');
            const overflowDropdown = document.getElementById('overflowDropdown');

            // Swipe-to-dismiss controller (declared before closeAllDropdowns which references it)
            let swipeAbortController = null;

            function closeAllDropdowns() {
                // Clean up swipe listeners
                if (swipeAbortController) { swipeAbortController.abort(); swipeAbortController = null; }
                // Reset inline transform from swipe gesture
                [highlightDropdown, drawDropdown, shapesDropdown, overflowDropdown].forEach(dd => {
                    dd.style.transform = '';
                    dd.style.transition = '';
                });
                highlightDropdown.classList.remove('visible');
                drawDropdown.classList.remove('visible');
                shapesDropdown.classList.remove('visible');
                overflowDropdown.classList.remove('visible');
                dropdownBackdrop.classList.remove('visible');
            }

            function toggleDropdown(dropdown, e) {
                e.stopPropagation();
                const isVisible = dropdown.classList.contains('visible');
                closeAllDropdowns();
                if (!isVisible) {
                    const useBottomSheet = isMobile() || isTabletPortrait();
                    // Add drag handle for mobile/tablet portrait bottom sheets
                    if (useBottomSheet && !dropdown.querySelector('.bottomSheetHandle')) {
                        const handle = document.createElement('div');
                        handle.className = 'bottomSheetHandle';
                        dropdown.insertBefore(handle, dropdown.firstChild);
                    }
                    dropdown.classList.add('visible');
                    // Show backdrop on mobile/tablet portrait
                    if (useBottomSheet) {
                        dropdownBackdrop.classList.add('visible');
                        setupBottomSheetSwipe(dropdown);
                    }
                }
            }

            // Bottom sheet swipe-to-dismiss (uses AbortController to prevent listener accumulation)
            function setupBottomSheetSwipe(dropdown) {
                // Abort previous swipe listeners if any
                if (swipeAbortController) swipeAbortController.abort();
                swipeAbortController = new AbortController();
                const signal = swipeAbortController.signal;

                let startY = 0, currentY = 0, isDragging = false;

                dropdown.addEventListener('touchstart', (e) => {
                    const rect = dropdown.getBoundingClientRect();
                    const touchY = e.touches[0].clientY;
                    if (touchY - rect.top > 40 && dropdown.scrollTop > 0) return;
                    startY = touchY;
                    currentY = startY;
                    isDragging = true;
                    dropdown.style.transition = 'none';
                }, { signal });

                dropdown.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    currentY = e.touches[0].clientY;
                    const dy = currentY - startY;
                    if (dy > 0) {
                        dropdown.style.transform = `translateY(${dy}px)`;
                        e.preventDefault();
                    }
                }, { passive: false, signal });

                dropdown.addEventListener('touchend', () => {
                    if (!isDragging) return;
                    isDragging = false;
                    const dy = currentY - startY;
                    dropdown.style.transition = '';
                    if (dy > 80) {
                        closeAllDropdowns();
                    }
                    dropdown.style.transform = '';
                }, { signal });
            }

            // Backdrop click closes dropdowns
            dropdownBackdrop.addEventListener('click', () => {
                closeAllDropdowns();
            });

            // Arrow buttons toggle dropdowns
            document.getElementById('highlightArrow').onclick = (e) => toggleDropdown(highlightDropdown, e);
            document.getElementById('drawArrow').onclick = (e) => toggleDropdown(drawDropdown, e);
            document.getElementById('shapesArrow').onclick = (e) => toggleDropdown(shapesDropdown, e);

            // Overflow menu toggle
            document.getElementById('overflowBtn').onclick = (e) => toggleDropdown(overflowDropdown, e);
            overflowDropdown.onclick = (e) => e.stopPropagation();

            // Overflow menu actions
            document.getElementById('overflowRotateLeft').onclick = () => {
                rotatePage(-90);
                closeAllDropdowns();
            };
            document.getElementById('overflowRotateRight').onclick = () => {
                rotatePage(90);
                closeAllDropdowns();
            };
            document.getElementById('overflowSepia').onclick = () => {
                document.getElementById('sepiaBtn').click();
                document.getElementById('overflowSepia').classList.toggle('active',
                    document.getElementById('sepiaBtn').classList.contains('active'));
                closeAllDropdowns();
            };

            // Close dropdowns when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.toolDropdown') && !e.target.closest('.dropdownArrow')) {
                    closeAllDropdowns();
                }
            });

            // Prevent dropdown from closing when clicking inside
            highlightDropdown.onclick = (e) => e.stopPropagation();
            drawDropdown.onclick = (e) => e.stopPropagation();
            shapesDropdown.onclick = (e) => e.stopPropagation();

            // Drawing Tools - Toggle Behavior
            async function setTool(tool) {
                // If same tool clicked again, deactivate
                if (currentTool === tool) {
                    currentTool = null;
                    annotationMode = false;
                    document.querySelectorAll('.annotationLayer').forEach(el => el.classList.remove('active'));
                } else {
                    currentTool = tool;
                    annotationMode = true;

                    // Set color and width based on tool
                    if (tool === 'highlight') {
                        currentColor = highlightColor;
                        currentWidth = highlightWidth;
                    } else if (tool === 'pen') {
                        currentColor = drawColor;
                        currentWidth = drawWidth;
                    } else if (tool === 'shape') {
                        currentColor = shapeColor;
                        currentWidth = shapeWidth;
                    }

                    // Performance: Just toggle active class instead of re-injecting layers
                    // This avoids expensive DOM recreation on every tool change
                    document.querySelectorAll('.annotationLayer').forEach(layer => {
                        layer.classList.toggle('active', annotationMode);
                    });
                }

                // Update button states
                highlightWrapper.classList.toggle('active', currentTool === 'highlight');
                drawWrapper.classList.toggle('active', currentTool === 'pen');
                shapesWrapper.classList.toggle('active', currentTool === 'shape');
                document.getElementById('eraserBtn').classList.toggle('active', currentTool === 'eraser');
                document.getElementById('textBtn').classList.toggle('active', currentTool === 'text');
                document.getElementById('selectBtn').classList.toggle('active', currentTool === 'select');

                // Toggle select-mode class on annotation layers
                document.querySelectorAll('.annotationLayer').forEach(layer => {
                    layer.classList.toggle('select-mode', currentTool === 'select');
                });

                // Clear selection when switching tools
                if (currentTool !== 'select') {
                    clearAnnotationSelection();
                }
            }

            document.getElementById('drawBtn').onclick = () => setTool('pen');
            document.getElementById('highlightBtn').onclick = () => setTool('highlight');
            document.getElementById('shapesBtn').onclick = () => setTool('shape');
            document.getElementById('eraserBtn').onclick = () => setTool('eraser');
            document.getElementById('textBtn').onclick = () => setTool('text');
            document.getElementById('selectBtn').onclick = () => setTool('select');

            // Undo / Redo / Clear All
            document.getElementById('undoBtn').onclick = () => performUndo();
            document.getElementById('redoBtn').onclick = () => performRedo();
            document.getElementById('clearAllBtn').onclick = () => performClearAll();

            // Highlighter Colors
            document.querySelectorAll('#highlightColors .colorDot').forEach(dot => {
                dot.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('#highlightColors .colorDot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    highlightColor = dot.dataset.color;
                    if (currentTool === 'highlight') currentColor = highlightColor;
                    // Update preview
                    document.getElementById('highlightWave').setAttribute('stroke', highlightColor);
                };
            });

            // Pen Colors
            document.querySelectorAll('#drawColors .colorDot').forEach(dot => {
                dot.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('#drawColors .colorDot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    drawColor = dot.dataset.color;
                    if (currentTool === 'pen') currentColor = drawColor;
                    // Update preview
                    document.getElementById('drawWave').setAttribute('stroke', drawColor);
                };
            });

            // Highlighter Thickness Slider
            document.getElementById('highlightThickness').oninput = (e) => {
                highlightWidth = parseInt(e.target.value);
                if (currentTool === 'highlight') currentWidth = highlightWidth;
                // Update preview - highlighter uses width * 2 for display
                document.getElementById('highlightWave').setAttribute('stroke-width', highlightWidth * 2);
            };

            // Pen Thickness Slider
            document.getElementById('drawThickness').oninput = (e) => {
                drawWidth = parseInt(e.target.value);
                if (currentTool === 'pen') currentWidth = drawWidth;
                // Update preview
                document.getElementById('drawWave').setAttribute('stroke-width', drawWidth);
            };

            // Shape Selection
            document.querySelectorAll('.shapeBtn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.shapeBtn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentShape = btn.dataset.shape;
                };
            });

            // Shape Colors
            document.querySelectorAll('#shapeColors .colorDot').forEach(dot => {
                dot.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('#shapeColors .colorDot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                    shapeColor = dot.dataset.color;
                    if (currentTool === 'shape') currentColor = shapeColor;
                };
            });

            // Shape Thickness Slider
            document.getElementById('shapeThickness').oninput = (e) => {
                shapeWidth = parseInt(e.target.value);
                if (currentTool === 'shape') currentWidth = shapeWidth;
            };

            // Annotation Layer with Persistence
            async function injectAnnotationLayer(pageNum) {
                const pageView = pdfViewer.getPageView(pageNum - 1);
                if (!pageView?.div) return;

                // Remove old SVG and abort its event listeners
                const oldSvg = pageView.div.querySelector('.annotationLayer');
                if (oldSvg) oldSvg.remove();
                const oldController = annotationAbortControllers.get(pageNum);
                if (oldController) oldController.abort();

                // Get or calculate base dimensions (scale=1.0, current rotation)
                const currentRotation = pdfViewer.pagesRotation || 0;
                let baseDims = pageBaseDimensions.get(pageNum);
                if (!baseDims) {
                    const page = await pdfDoc.getPage(pageNum);
                    const baseViewport = page.getViewport({ scale: 1.0, rotation: currentRotation });
                    baseDims = { width: baseViewport.width, height: baseViewport.height };
                    pageBaseDimensions.set(pageNum, baseDims);
                }

                // Create fresh SVG with viewBox matching rotated dimensions
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'annotationLayer');
                svg.setAttribute('viewBox', `0 0 ${baseDims.width} ${baseDims.height}`);
                svg.setAttribute('preserveAspectRatio', 'none');
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.dataset.page = pageNum;
                svg.dataset.viewboxWidth = baseDims.width;
                svg.dataset.viewboxHeight = baseDims.height;

                pageView.div.appendChild(svg);



                // Restore saved annotations for this page (with rotation transform if needed)
                if (annotationsStore.has(pageNum)) {
                    const savedRot = annotationRotations.get(pageNum) || 0;
                    const curRot = pdfViewer.pagesRotation || 0;
                    const delta = (curRot - savedRot + 360) % 360;

                    if (delta === 0) {
                        svg.innerHTML = annotationsStore.get(pageNum);
                    } else {
                        // Get unrotated page dimensions for transform calculation
                        const page = await pdfDoc.getPage(pageNum);
                        const unrotVP = page.getViewport({ scale: 1.0 });
                        const W = unrotVP.width, H = unrotVP.height;

                        // Old viewBox dimensions (at saved rotation)
                        let oW, oH;
                        if (savedRot === 90 || savedRot === 270) { oW = H; oH = W; }
                        else { oW = W; oH = H; }

                        let transform;
                        if (delta === 90) transform = `translate(${oH},0) rotate(90)`;
                        else if (delta === 180) transform = `translate(${oW},${oH}) rotate(180)`;
                        else if (delta === 270) transform = `translate(0,${oW}) rotate(270)`;

                        svg.innerHTML = `<g transform="${transform}">${annotationsStore.get(pageNum)}</g>`;

                        // Update stored annotations & rotation to current
                        annotationsStore.set(pageNum, svg.innerHTML);
                        annotationRotations.set(pageNum, curRot);

                        // Note: No need to wrap stack entries anymore
                        // Rotation is now stored per-entry, transforms applied on restore
                    }
                }

                // Bug fix: Use AbortController for cleanup when page re-renders
                const controller = new AbortController();
                const signal = controller.signal;
                annotationAbortControllers.set(pageNum, controller);

                svg.addEventListener('mousedown', (e) => startDraw(e, pageNum), { signal });
                svg.addEventListener('mousemove', draw, { signal });
                svg.addEventListener('mouseup', () => stopDraw(pageNum), { signal });
                svg.addEventListener('mouseleave', () => stopDraw(pageNum), { signal });

                // Touch support for tablets
                svg.addEventListener('touchstart', (e) => {
                    // Prevent default to avoid scroll while drawing/selecting
                    if (currentTool) e.preventDefault();
                    startDraw(e, pageNum);
                }, { passive: false, signal });
                svg.addEventListener('touchmove', (e) => {
                    if (currentTool) e.preventDefault();
                    draw(e);
                }, { passive: false, signal });
                svg.addEventListener('touchend', () => stopDraw(pageNum), { signal });
                svg.addEventListener('touchcancel', () => stopDraw(pageNum), { signal });

                svg.classList.toggle('active', annotationMode);
            }

            // Strip transient classes, styles, and elements from SVG before saving
            function getCleanSvgInnerHTML(svg) {
                // Performance: Work on a cloned node to avoid modifying live DOM
                const clone = svg.cloneNode(true);

                // Remove marquee rect if present
                const marquee = clone.querySelector('.marquee-rect');
                if (marquee) marquee.remove();

                // Strip transient classes and inline styles from annotation elements
                const transientClasses = ['annotation-selected', 'annotation-multi-selected', 'annotation-dragging', 'just-selected'];
                clone.querySelectorAll('path, rect, ellipse, line, text').forEach(el => {
                    transientClasses.forEach(cls => el.classList.remove(cls));
                    // Remove inline cursor style added by multi-drag
                    if (el.style.cursor) el.style.cursor = '';
                    // Clean up empty style attribute
                    if (el.getAttribute('style') === '') el.removeAttribute('style');
                    // Clean up empty class attribute
                    if (el.getAttribute('class') === '') el.removeAttribute('class');
                });

                return clone.innerHTML.trim();
            }

            // Helper: Apply rotation transform from savedRot to curRot
            // Uses clone-based flatten approach - updates each element's transform individually
            // This prevents nested <g> accumulation entirely
            function applyRotationTransform(html, savedRot, curRot, pageNum) {
                if (!html || !html.trim()) return html;

                const delta = (curRot - savedRot + 360) % 360;
                if (delta === 0) return html;

                // Calculate transform based on page dimensions
                const baseDims = pageBaseDimensions.get(pageNum);
                if (!baseDims) return html; // Fallback if no dims available

                const W = baseDims.width, H = baseDims.height;

                // Old viewBox dimensions (at saved rotation)
                let oW, oH;
                if (savedRot === 90 || savedRot === 270) { oW = H; oH = W; }
                else { oW = W; oH = H; }

                let rotationTransform;
                if (delta === 90) rotationTransform = `translate(${oH},0) rotate(90)`;
                else if (delta === 180) rotationTransform = `translate(${oW},${oH}) rotate(180)`;
                else if (delta === 270) rotationTransform = `translate(0,${oW}) rotate(270)`;
                else return html;

                // Clone-based flatten: Apply transform to each top-level element individually
                const tempContainer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                tempContainer.innerHTML = html;

                // Process each top-level child element
                Array.from(tempContainer.children).forEach(child => {
                    const existingTransform = child.getAttribute('transform') || '';
                    // Prepend rotation transform (rotation first, then existing)
                    const newTransform = existingTransform
                        ? `${rotationTransform} ${existingTransform}`
                        : rotationTransform;
                    child.setAttribute('transform', newTransform);
                });

                return tempContainer.innerHTML;
            }

            // Save annotations for a page (with undo history)
            function saveAnnotations(pageNum) {
                const pageView = pdfViewer.getPageView(pageNum - 1);
                const svg = pageView?.div?.querySelector('.annotationLayer');
                if (!svg) return;

                // Push previous state to undo stack before saving new state
                const previousState = annotationsStore.get(pageNum) || '';
                const newState = getCleanSvgInnerHTML(svg);

                // Only push to history if state actually changed
                if (previousState !== newState) {
                    if (!undoStacks.has(pageNum)) undoStacks.set(pageNum, []);
                    const stack = undoStacks.get(pageNum);
                    // Store as {html, rotation} object to avoid nested <g> wrap accumulation
                    stack.push({ html: previousState, rotation: annotationRotations.get(pageNum) || 0 });
                    if (stack.length > MAX_HISTORY) stack.shift();

                    // Clear redo stack on new action
                    redoStacks.delete(pageNum);
                }

                if (newState) {
                    annotationsStore.set(pageNum, newState);
                    annotationRotations.set(pageNum, pdfViewer.pagesRotation || 0);
                } else {
                    annotationsStore.delete(pageNum);
                    annotationRotations.delete(pageNum);
                }

                updateUndoRedoButtons();
            }

            function updateUndoRedoButtons() {
                const pageNum = pdfViewer ? pdfViewer.currentPageNumber : 0;
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                const undoStack = undoStacks.get(pageNum);
                const redoStack = redoStacks.get(pageNum);
                undoBtn.disabled = !undoStack || undoStack.length === 0;
                redoBtn.disabled = !redoStack || redoStack.length === 0;
            }

            function performUndo() {
                const pageNum = pdfViewer.currentPageNumber;
                const stack = undoStacks.get(pageNum);
                if (!stack || stack.length === 0) return;

                const pageView = pdfViewer.getPageView(pageNum - 1);
                const svg = pageView?.div?.querySelector('.annotationLayer');
                if (!svg) return;

                // Save current state to redo stack with rotation
                if (!redoStacks.has(pageNum)) redoStacks.set(pageNum, []);
                const redoStack = redoStacks.get(pageNum);
                redoStack.push({ html: getCleanSvgInnerHTML(svg), rotation: pdfViewer.pagesRotation || 0 });
                if (redoStack.length > MAX_HISTORY) redoStack.shift();

                // Restore previous state with rotation transform if needed
                const entry = stack.pop();
                const previousHtml = typeof entry === 'object' ? entry.html : entry;
                const savedRot = typeof entry === 'object' ? entry.rotation : (annotationRotations.get(pageNum) || 0);
                const curRot = pdfViewer.pagesRotation || 0;

                svg.innerHTML = applyRotationTransform(previousHtml, savedRot, curRot, pageNum);

                // Update store
                if (previousHtml.trim()) {
                    annotationsStore.set(pageNum, svg.innerHTML);
                    annotationRotations.set(pageNum, curRot);
                } else {
                    annotationsStore.delete(pageNum);
                    annotationRotations.delete(pageNum);
                }

                clearAnnotationSelection();
                updateUndoRedoButtons();
            }

            function performRedo() {
                const pageNum = pdfViewer.currentPageNumber;
                const stack = redoStacks.get(pageNum);
                if (!stack || stack.length === 0) return;

                const pageView = pdfViewer.getPageView(pageNum - 1);
                const svg = pageView?.div?.querySelector('.annotationLayer');
                if (!svg) return;

                // Save current state to undo stack with rotation
                if (!undoStacks.has(pageNum)) undoStacks.set(pageNum, []);
                const undoStack = undoStacks.get(pageNum);
                undoStack.push({ html: getCleanSvgInnerHTML(svg), rotation: pdfViewer.pagesRotation || 0 });
                if (undoStack.length > MAX_HISTORY) undoStack.shift();

                // Restore redo state with rotation transform if needed
                const entry = stack.pop();
                const redoHtml = typeof entry === 'object' ? entry.html : entry;
                const savedRot = typeof entry === 'object' ? entry.rotation : (annotationRotations.get(pageNum) || 0);
                const curRot = pdfViewer.pagesRotation || 0;

                svg.innerHTML = applyRotationTransform(redoHtml, savedRot, curRot, pageNum);

                // Update store
                if (redoHtml.trim()) {
                    annotationsStore.set(pageNum, svg.innerHTML);
                    annotationRotations.set(pageNum, curRot);
                } else {
                    annotationsStore.delete(pageNum);
                    annotationRotations.delete(pageNum);
                }

                clearAnnotationSelection();
                updateUndoRedoButtons();
            }

            function performClearAll() {
                const pageNum = pdfViewer.currentPageNumber;
                const pageView = pdfViewer.getPageView(pageNum - 1);
                const svg = pageView?.div?.querySelector('.annotationLayer');
                if (!svg || !svg.innerHTML.trim()) return;

                // Save current state to undo stack with rotation
                if (!undoStacks.has(pageNum)) undoStacks.set(pageNum, []);
                const stack = undoStacks.get(pageNum);
                stack.push({ html: getCleanSvgInnerHTML(svg), rotation: pdfViewer.pagesRotation || 0 });
                if (stack.length > MAX_HISTORY) stack.shift();

                // Clear redo stack
                redoStacks.delete(pageNum);

                // Clear all annotations
                svg.innerHTML = '';
                annotationsStore.delete(pageNum);
                annotationRotations.delete(pageNum);

                clearAnnotationSelection();
                updateUndoRedoButtons();
            }

            function startDraw(e, pageNum) {
                if (!annotationMode || !currentTool) return;

                e.preventDefault(); // Prevent text selection

                const svg = e.currentTarget;
                if (!svg || !svg.dataset.viewboxWidth) return; // Defensive check

                // Handle select tool separately
                if (currentTool === 'select') {
                    if (handleSelectMouseDown(e, svg, pageNum)) {
                        return; // Select tool handled the event
                    }
                }

                isDrawing = true;
                currentDrawingPage = pageNum;
                currentSvg = svg; // Store reference

                // Convert screen coords to viewBox coords (rotation-aware)
                const coords = getEventCoords(e);
                const vb = screenToViewBox(svg, coords.clientX, coords.clientY);
                const x = vb.x;
                const y = vb.y;
                const scaleX = vb.scaleX;
                const scaleY = vb.scaleY;

                if (currentTool === 'eraser') {
                    eraseAt(svg, x, y, scaleX, coords.clientX, coords.clientY);
                    // Performance: Don't save here - isDrawing is true, stopDraw will save on mouseup
                    return;
                }

                // Text tool - create/edit/drag text
                if (currentTool === 'text') {
                    // Check if clicked on existing text element
                    const elementsUnderClick = document.elementsFromPoint(e.clientX, e.clientY);
                    const existingText = elementsUnderClick.find(el => el.tagName === 'text' && el.closest('.annotationLayer'));

                    if (existingText) {
                        // Start dragging (double-click will edit via separate handler)
                        startTextDrag(e, existingText, svg, scaleX, pageNum);
                    } else {
                        // Create new text
                        showTextEditor(e.clientX, e.clientY, svg, x, y, scaleX, pageNum);
                    }
                    return;
                }

                // Shape tool - create shapes
                if (currentTool === 'shape') {
                    isDrawing = true;
                    // Store start position for shape drawing
                    svg.dataset.shapeStartX = x;
                    svg.dataset.shapeStartY = y;
                    svg.dataset.shapeScaleX = scaleX;
                    svg.dataset.shapeScaleY = scaleY;

                    let shapeEl;
                    if (currentShape === 'rectangle') {
                        shapeEl = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        shapeEl.setAttribute('x', x);
                        shapeEl.setAttribute('y', y);
                        shapeEl.setAttribute('width', 0);
                        shapeEl.setAttribute('height', 0);
                    } else if (currentShape === 'circle') {
                        shapeEl = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
                        shapeEl.setAttribute('cx', x);
                        shapeEl.setAttribute('cy', y);
                        shapeEl.setAttribute('rx', 0);
                        shapeEl.setAttribute('ry', 0);
                    } else if (currentShape === 'line' || currentShape === 'arrow') {
                        shapeEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        shapeEl.setAttribute('x1', x);
                        shapeEl.setAttribute('y1', y);
                        shapeEl.setAttribute('x2', x);
                        shapeEl.setAttribute('y2', y);
                    }

                    shapeEl.setAttribute('stroke', currentColor);
                    shapeEl.setAttribute('stroke-width', String(currentWidth * scaleX));
                    shapeEl.setAttribute('fill', 'none');
                    shapeEl.classList.add('current-shape');
                    svg.appendChild(shapeEl);
                    return;
                }

                currentPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentPath.setAttribute('stroke', currentColor);
                currentPath.setAttribute('fill', 'none');

                if (currentTool === 'highlight') {
                    // Highlighter uses stroke size * 5 for thicker strokes
                    currentPath.setAttribute('stroke-width', String(currentWidth * 5 * scaleX));
                    currentPath.setAttribute('stroke-opacity', '0.35');
                } else {
                    currentPath.setAttribute('stroke-width', String(currentWidth * scaleX));
                    currentPath.setAttribute('stroke-opacity', '1');
                }

                currentPath.setAttribute('d', `M${x.toFixed(2)},${y.toFixed(2)}`);
                svg.appendChild(currentPath);
            }

            function draw(e) {
                if (!isDrawing || !currentSvg) return;

                // Bug fix: Check if SVG is still in DOM (prevents stale reference)
                if (!currentSvg.isConnected) {
                    isDrawing = false;
                    currentPath = null;
                    currentSvg = null;
                    currentDrawingPage = null;
                    return;
                }

                e.preventDefault(); // Prevent text selection

                const svg = currentSvg; // Use stored reference
                if (!svg || !svg.dataset.viewboxWidth) return;

                // Convert screen coords to viewBox coords (rotation-aware)
                const coords = getEventCoords(e);
                const vb = screenToViewBox(svg, coords.clientX, coords.clientY);
                const x = vb.x;
                const y = vb.y;
                const scaleX = vb.scaleX;

                if (currentTool === 'eraser') {
                    eraseAt(svg, x, y, scaleX, coords.clientX, coords.clientY);
                    // Performance: Don't save on every mousemove - let mouseup handle it
                    return;
                }

                // Shape tool - update shape size
                if (currentTool === 'shape') {
                    const shapeEl = svg.querySelector('.current-shape');
                    if (!shapeEl) return;

                    const startX = parseFloat(svg.dataset.shapeStartX);
                    const startY = parseFloat(svg.dataset.shapeStartY);

                    if (currentShape === 'rectangle') {
                        const width = Math.abs(x - startX);
                        const height = Math.abs(y - startY);
                        shapeEl.setAttribute('x', Math.min(x, startX));
                        shapeEl.setAttribute('y', Math.min(y, startY));
                        shapeEl.setAttribute('width', width);
                        shapeEl.setAttribute('height', height);
                    } else if (currentShape === 'circle') {
                        const rx = Math.abs(x - startX) / 2;
                        const ry = Math.abs(y - startY) / 2;
                        shapeEl.setAttribute('cx', (startX + x) / 2);
                        shapeEl.setAttribute('cy', (startY + y) / 2);
                        shapeEl.setAttribute('rx', rx);
                        shapeEl.setAttribute('ry', ry);
                    } else if (currentShape === 'line' || currentShape === 'arrow' || currentShape === 'callout') {
                        shapeEl.setAttribute('x2', x);
                        shapeEl.setAttribute('y2', y);
                    }
                    return;
                }

                // RAF throttle: buffer segments and flush in animation frame
                if (currentPath) {
                    pathSegments.push(`L${x.toFixed(2)},${y.toFixed(2)}`);

                    if (!drawRAF) {
                        drawRAF = requestAnimationFrame(() => {
                            if (currentPath && pathSegments.length > 0) {
                                currentPath.setAttribute('d', currentPath.getAttribute('d') + ' ' + pathSegments.join(' '));
                                pathSegments = [];
                            }
                            drawRAF = null;
                        });
                    }
                }
            }

            function stopDraw(pageNum) {
                // Flush any pending path segments before stopping
                if (drawRAF) {
                    cancelAnimationFrame(drawRAF);
                    drawRAF = null;
                }
                if (currentPath && pathSegments.length > 0) {
                    currentPath.setAttribute('d', currentPath.getAttribute('d') + ' ' + pathSegments.join(' '));
                    pathSegments = [];
                }

                // Handle arrow marker
                if (currentTool === 'shape' && currentShape === 'arrow' && currentSvg) {
                    const shapeEl = currentSvg.querySelector('.current-shape');
                    if (shapeEl && shapeEl.tagName === 'line') {
                        // Create arrow head as a group
                        const x1 = parseFloat(shapeEl.getAttribute('x1'));
                        const y1 = parseFloat(shapeEl.getAttribute('y1'));
                        const x2 = parseFloat(shapeEl.getAttribute('x2'));
                        const y2 = parseFloat(shapeEl.getAttribute('y2'));

                        // Calculate arrow head
                        const angle = Math.atan2(y2 - y1, x2 - x1);
                        const headLength = 15 * parseFloat(currentSvg.dataset.shapeScaleX || 1);

                        const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const p1x = x2 - headLength * Math.cos(angle - Math.PI / 6);
                        const p1y = y2 - headLength * Math.sin(angle - Math.PI / 6);
                        const p2x = x2 - headLength * Math.cos(angle + Math.PI / 6);
                        const p2y = y2 - headLength * Math.sin(angle + Math.PI / 6);

                        arrowHead.setAttribute('d', `M${x2},${y2} L${p1x},${p1y} M${x2},${y2} L${p2x},${p2y}`);
                        arrowHead.setAttribute('stroke', shapeEl.getAttribute('stroke'));
                        arrowHead.setAttribute('stroke-width', shapeEl.getAttribute('stroke-width'));
                        arrowHead.setAttribute('fill', 'none');
                        currentSvg.appendChild(arrowHead);
                    }
                }

                // Handle callout - arrow with text at the start, pointing to end
                // UX: Click where you want text box, drag to point at something
                if (currentTool === 'shape' && currentShape === 'callout' && currentSvg) {
                    const shapeEl = currentSvg.querySelector('.current-shape');
                    if (shapeEl && shapeEl.tagName === 'line') {
                        const x1 = parseFloat(shapeEl.getAttribute('x1')); // Start - where text box goes
                        const y1 = parseFloat(shapeEl.getAttribute('y1'));
                        const x2 = parseFloat(shapeEl.getAttribute('x2')); // End - where arrow points
                        const y2 = parseFloat(shapeEl.getAttribute('y2'));

                        // Only create callout if line has been drawn (not just a click)
                        if (Math.abs(x2 - x1) > 5 || Math.abs(y2 - y1) > 5) {
                            const scaleX = parseFloat(currentSvg.dataset.shapeScaleX || 1);

                            // Arrow head points TO the end (x2,y2) - where user wants to point at
                            const angle = Math.atan2(y2 - y1, x2 - x1);
                            const headLength = 12 * scaleX;

                            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            const p1x = x2 - headLength * Math.cos(angle - Math.PI / 6);
                            const p1y = y2 - headLength * Math.sin(angle - Math.PI / 6);
                            const p2x = x2 - headLength * Math.cos(angle + Math.PI / 6);
                            const p2y = y2 - headLength * Math.sin(angle + Math.PI / 6);

                            arrowHead.setAttribute('d', `M${x2},${y2} L${p1x},${p1y} M${x2},${y2} L${p2x},${p2y}`);
                            arrowHead.setAttribute('stroke', shapeEl.getAttribute('stroke'));
                            arrowHead.setAttribute('stroke-width', shapeEl.getAttribute('stroke-width'));
                            arrowHead.setAttribute('fill', 'none');
                            arrowHead.classList.add('callout-arrow');
                            currentSvg.appendChild(arrowHead);

                            // Store references for text editor
                            const svg = currentSvg;
                            const currentPageNum = currentDrawingPage;
                            const arrowColor = shapeEl.getAttribute('stroke');

                            // Calculate screen position for text editor at START of arrow (x1,y1)
                            // This is where the user clicked first - where they want the text
                            const rect = svg.getBoundingClientRect();
                            const viewBoxWidth = parseFloat(svg.dataset.viewboxWidth);
                            const viewBoxHeight = parseFloat(svg.dataset.viewboxHeight);
                            const screenX = rect.left + (x1 / viewBoxWidth) * rect.width;
                            const screenY = rect.top + (y1 / viewBoxHeight) * rect.height;

                            // Remove the current-shape class before showing editor
                            shapeEl.classList.remove('current-shape');

                            // Save first, then open text editor
                            saveAnnotations(currentPageNum);

                            // Open text editor at the START of the arrow (where user clicked)
                            setTimeout(() => {
                                showTextEditor(screenX, screenY, svg, x1, y1, scaleX, currentPageNum, null, arrowColor);
                            }, 50);

                            // Reset state
                            isDrawing = false;
                            currentPath = null;
                            currentSvg = null;
                            currentDrawingPage = null;
                            return; // Exit early, text editor will handle the rest
                        }
                    }
                }

                // Remove the current-shape class
                if (currentSvg) {
                    const shapeEl = currentSvg.querySelector('.current-shape');
                    if (shapeEl) shapeEl.classList.remove('current-shape');
                }

                if (isDrawing && currentDrawingPage) {
                    saveAnnotations(currentDrawingPage);
                }
                isDrawing = false;
                currentPath = null;
                currentSvg = null;
                currentDrawingPage = null;
            }

            // Text Drag-and-Drop
            let draggedText = null;
            let dragStartX = 0;
            let dragStartY = 0;
            let textOriginalX = 0;
            let textOriginalY = 0;
            let hasDragged = false;

            function startTextDrag(e, textEl, svg, scaleX, pageNum) {
                e.preventDefault();
                e.stopPropagation();

                draggedText = textEl;
                textEl.classList.add('dragging');
                hasDragged = false;

                dragStartX = e.clientX;
                dragStartY = e.clientY;
                textOriginalX = parseFloat(textEl.getAttribute('x'));
                textOriginalY = parseFloat(textEl.getAttribute('y'));

                function onMouseMove(ev) {
                    const dxScreen = ev.clientX - dragStartX;
                    const dyScreen = ev.clientY - dragStartY;
                    // Convert screen delta to viewBox delta (rotation-aware)
                    const vbDelta = screenDeltaToViewBox(svg, dxScreen, dyScreen);

                    if (Math.abs(vbDelta.dx) > 2 || Math.abs(vbDelta.dy) > 2) {
                        hasDragged = true;
                    }

                    textEl.setAttribute('x', (textOriginalX + vbDelta.dx).toFixed(2));
                    textEl.setAttribute('y', (textOriginalY + vbDelta.dy).toFixed(2));
                }

                function onMouseUp(ev) {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    textEl.classList.remove('dragging');

                    if (hasDragged) {
                        // Moved - save position
                        saveAnnotations(pageNum);
                    } else {
                        // Not moved - short click = edit
                        const viewBoxWidth = parseFloat(svg.dataset.viewboxWidth);
                        const viewBoxHeight = parseFloat(svg.dataset.viewboxHeight);
                        const svgX = parseFloat(textEl.getAttribute('x'));
                        const svgY = parseFloat(textEl.getAttribute('y'));
                        // Note: showTextEditor needs scaleX for font scaling logic, which we still have from arguments
                        showTextEditor(ev.clientX, ev.clientY, svg, svgX, svgY, scaleX, pageNum, textEl);
                    }

                    draggedText = null;
                }

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }

            // Inline Text Editor
            let textFontSize = 20;

            function showTextEditor(screenX, screenY, svg, svgX, svgY, scale, pageNum, existingTextEl = null, overrideColor = null) {
                // Remove existing editor if any
                const existingOverlay = document.querySelector('.textEditorOverlay');
                if (existingOverlay) existingOverlay.remove();

                // Use override color (for callout) or current color
                let textColor = overrideColor || currentColor;

                // If editing existing text, get its properties
                let editingText = null;
                if (existingTextEl && typeof existingTextEl === 'object' && existingTextEl.textContent !== undefined) {
                    editingText = existingTextEl.textContent;
                    textFontSize = parseFloat(existingTextEl.getAttribute('font-size')) / scale || 20;
                    // Use existing text's color
                    textColor = existingTextEl.getAttribute('fill') || textColor;
                }

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'textEditorOverlay';

                // Create editor box
                const box = document.createElement('div');
                box.className = 'textEditorBox';
                box.style.left = screenX + 'px';
                box.style.top = screenY + 'px';

                // Input area
                const input = document.createElement('div');
                input.className = 'textEditorInput';
                input.contentEditable = true;
                input.style.color = textColor;
                input.style.fontSize = textFontSize + 'px';
                if (editingText) {
                    input.textContent = editingText;
                }

                // Toolbar
                const toolbar = document.createElement('div');
                toolbar.className = 'textEditorToolbar';

                // Color palette
                const colorsDiv = document.createElement('div');
                colorsDiv.className = 'textEditorColors';
                const textEditorColors = ['#000000', '#e81224', '#0078d4', '#16c60c', '#fff100', '#886ce4', '#ff8c00', '#ffffff'];
                let activeColor = textColor;

                textEditorColors.forEach(c => {
                    const dot = document.createElement('div');
                    dot.className = 'textEditorColorDot' + (c === activeColor ? ' active' : '');
                    dot.style.background = c;
                    if (c === '#ffffff') dot.style.border = '2px solid #ccc';
                    dot.onclick = (e) => {
                        e.stopPropagation();
                        activeColor = c;
                        input.style.color = c;
                        colorsDiv.querySelectorAll('.textEditorColorDot').forEach(d => d.classList.remove('active'));
                        dot.classList.add('active');
                    };
                    colorsDiv.appendChild(dot);
                });

                // Font size group: A⁻ [size] A⁺
                const sizeGroup = document.createElement('div');
                sizeGroup.className = 'textEditorSizeGroup';

                const sizeLabel = document.createElement('span');
                sizeLabel.className = 'textEditorSizeLabel';
                sizeLabel.textContent = textFontSize;

                const decreaseBtn = document.createElement('button');
                decreaseBtn.className = 'textEditorBtn';
                decreaseBtn.innerHTML = 'A<sup>-</sup>';
                decreaseBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (textFontSize > 10) {
                        textFontSize -= 2;
                        input.style.fontSize = textFontSize + 'px';
                        sizeLabel.textContent = textFontSize;
                    }
                };

                const increaseBtn = document.createElement('button');
                increaseBtn.className = 'textEditorBtn';
                increaseBtn.innerHTML = 'A<sup>+</sup>';
                increaseBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (textFontSize < 60) {
                        textFontSize += 2;
                        input.style.fontSize = textFontSize + 'px';
                        sizeLabel.textContent = textFontSize;
                    }
                };

                sizeGroup.appendChild(decreaseBtn);
                sizeGroup.appendChild(sizeLabel);
                sizeGroup.appendChild(increaseBtn);

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'textEditorBtn delete';
                deleteBtn.innerHTML = '🗑️';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (existingTextEl) {
                        existingTextEl.remove();
                        saveAnnotations(pageNum);
                    }
                    overlay.remove();
                };

                toolbar.appendChild(colorsDiv);
                toolbar.appendChild(sizeGroup);
                toolbar.appendChild(deleteBtn);

                box.appendChild(input);
                box.appendChild(toolbar);
                overlay.appendChild(box);
                document.body.appendChild(overlay);

                // Focus input and select all if editing
                setTimeout(() => {
                    input.focus();
                    if (editingText) {
                        const range = document.createRange();
                        range.selectNodeContents(input);
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }, 50);

                // Confirm on click outside or Enter
                function confirmText() {
                    const text = input.textContent.trim();
                    if (text) {
                        if (existingTextEl) {
                            // Update existing text element
                            existingTextEl.textContent = text;
                            existingTextEl.setAttribute('fill', activeColor);
                            existingTextEl.setAttribute('font-size', String(textFontSize * scale));
                        } else {
                            // Create new text element
                            const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            textEl.setAttribute('x', svgX.toFixed(2));
                            textEl.setAttribute('y', svgY.toFixed(2));
                            textEl.setAttribute('fill', activeColor);
                            textEl.setAttribute('font-size', String(textFontSize * scale));
                            textEl.setAttribute('font-family', 'Segoe UI, Arial, sans-serif');
                            textEl.textContent = text;
                            svg.appendChild(textEl);
                        }
                        saveAnnotations(pageNum);
                    } else if (existingTextEl) {
                        // Empty text = delete existing
                        existingTextEl.remove();
                        saveAnnotations(pageNum);
                    }
                    overlay.remove();
                }

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) confirmText();
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        confirmText();
                    }
                    if (e.key === 'Escape') {
                        overlay.remove();
                    }
                });
            }

            function eraseAt(svg, x, y, scale = 1, clientX, clientY) {
                // Use elementsFromPoint for rotation-aware hit testing
                const annotationTags = new Set(['path', 'text', 'rect', 'ellipse', 'line']);
                const elements = document.elementsFromPoint(clientX, clientY);
                elements.forEach(el => {
                    if (el.closest('.annotationLayer') === svg && annotationTags.has(el.tagName)) {
                        el.remove();
                    }
                });

                // Also erase text highlights (in separate container)
                const pageDiv = svg.closest('.page');
                if (pageDiv) {
                    const highlightContainer = pageDiv.querySelector('.textHighlightContainer');
                    if (highlightContainer) {
                        const pageRect = pageDiv.getBoundingClientRect();
                        const vbW = parseFloat(svg.dataset.viewboxWidth);
                        const vbH = parseFloat(svg.dataset.viewboxHeight);
                        // Convert viewBox coords to percentage (independent of rotation)
                        const screenXPercent = (x / vbW) * 100;
                        const screenYPercent = (y / vbH) * 100;

                        highlightContainer.querySelectorAll('.textHighlight').forEach(el => {
                            const left = parseFloat(el.style.left); // Already in %
                            const top = parseFloat(el.style.top);
                            const width = parseFloat(el.style.width);
                            const height = parseFloat(el.style.height);

                            if (screenXPercent >= left - 2 && screenXPercent <= left + width + 2 &&
                                screenYPercent >= top - 2 && screenYPercent <= top + height + 2) {
                                el.remove();
                                // Save changes
                                const pageNum = parseInt(pageDiv.dataset.pageNumber);
                                saveTextHighlights(pageNum, pageDiv);
                            }
                        });
                    }
                }
            }

            // ==========================================
            // TEXT SELECTION HIGHLIGHTING (Adobe/Edge style)
            // ==========================================
            let highlightPopup = null;

            function removeHighlightPopup() {
                if (highlightPopup) {
                    highlightPopup.remove();
                    highlightPopup = null;
                }
            }

            function getSelectionRects() {
                const selection = window.getSelection();
                if (!selection || selection.isCollapsed || !selection.rangeCount) return null;

                const range = selection.getRangeAt(0);
                const rects = range.getClientRects();
                if (rects.length === 0) return null;

                // Find which page the selection is in
                const startNode = range.startContainer.parentElement;
                const textLayer = startNode?.closest('.textLayer');
                if (!textLayer) return null;

                const pageDiv = textLayer.closest('.page');
                if (!pageDiv) return null;

                const pageNum = parseInt(pageDiv.dataset.pageNumber);
                const pageRect = pageDiv.getBoundingClientRect();

                // Convert rects to page-relative coordinates
                const relativeRects = [];
                for (let i = 0; i < rects.length; i++) {
                    const rect = rects[i];
                    relativeRects.push({
                        x: rect.left - pageRect.left,
                        y: rect.top - pageRect.top,
                        width: rect.width,
                        height: rect.height
                    });
                }

                return { pageNum, pageDiv, relativeRects, lastRect: rects[rects.length - 1] };
            }

            function createTextHighlights(pageDiv, rects, color) {
                // Find or create highlight container
                let highlightContainer = pageDiv.querySelector('.textHighlightContainer');
                if (!highlightContainer) {
                    highlightContainer = document.createElement('div');
                    highlightContainer.className = 'textHighlightContainer';
                    highlightContainer.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:5;';
                    pageDiv.insertBefore(highlightContainer, pageDiv.firstChild);
                }

                // Get page dimensions for percentage calculation
                const pageRect = pageDiv.getBoundingClientRect();
                const pageWidth = pageRect.width;
                const pageHeight = pageRect.height;

                // Add highlight rectangles with percentage positioning
                rects.forEach(rect => {
                    const div = document.createElement('div');
                    div.className = 'textHighlight';

                    // Convert to percentages for zoom-independent positioning
                    const leftPercent = (rect.x / pageWidth) * 100;
                    const topPercent = (rect.y / pageHeight) * 100;
                    const widthPercent = (rect.width / pageWidth) * 100;
                    const heightPercent = (rect.height / pageHeight) * 100;

                    div.style.cssText = `
                    left: ${leftPercent}%;
                    top: ${topPercent}%;
                    width: ${widthPercent}%;
                    height: ${heightPercent}%;
                    background: ${color};
                    opacity: 0.35;
                `;
                    highlightContainer.appendChild(div);
                });

                // Save to annotations store
                const pageNum = parseInt(pageDiv.dataset.pageNumber);
                saveTextHighlights(pageNum, pageDiv);
            }

            function saveTextHighlights(pageNum, pageDiv) {
                const container = pageDiv.querySelector('.textHighlightContainer');
                if (container) {
                    const key = `textHighlight_${pageNum}`;
                    localStorage.setItem(key, container.innerHTML);
                }
            }

            function loadTextHighlights(pageNum, pageDiv) {
                const key = `textHighlight_${pageNum}`;
                const saved = localStorage.getItem(key);
                if (saved) {
                    let container = pageDiv.querySelector('.textHighlightContainer');
                    if (!container) {
                        container = document.createElement('div');
                        container.className = 'textHighlightContainer';
                        container.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:5;';
                        pageDiv.insertBefore(container, pageDiv.firstChild);
                    }
                    container.innerHTML = saved;
                }
            }

            function showHighlightPopup(x, y, pageDiv, rects) {
                removeHighlightPopup();

                highlightPopup = document.createElement('div');
                highlightPopup.className = 'highlightPopup';
                highlightPopup.style.left = x + 'px';
                highlightPopup.style.top = (y + 10) + 'px';

                const colors = ['#fff100', '#16c60c', '#00b7c3', '#0078d4', '#886ce4', '#e81224'];
                colors.forEach(color => {
                    const btn = document.createElement('button');
                    btn.style.background = color;
                    btn.title = 'Vurgula';
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        createTextHighlights(pageDiv, rects, color);
                        window.getSelection().removeAllRanges();
                        removeHighlightPopup();
                    };
                    highlightPopup.appendChild(btn);
                });

                document.body.appendChild(highlightPopup);
            }

            // Listen for text selection
            document.addEventListener('mouseup', (e) => {
                // Small delay to let selection finalize
                setTimeout(() => {
                    const selData = getSelectionRects();
                    if (selData && selData.relativeRects.length > 0) {
                        const lastRect = selData.lastRect;
                        showHighlightPopup(lastRect.right, lastRect.bottom, selData.pageDiv, selData.relativeRects);
                    } else {
                        removeHighlightPopup();
                    }
                }, 10);
            });

            // Remove popup on click elsewhere
            document.addEventListener('mousedown', (e) => {
                if (highlightPopup && !highlightPopup.contains(e.target)) {
                    removeHighlightPopup();
                }
            });

            // Load text highlights when pages render
            eventBus.on('pagerendered', (evt) => {
                const pageDiv = pdfViewer.getPageView(evt.pageNumber - 1)?.div;
                if (pageDiv) {
                    loadTextHighlights(evt.pageNumber, pageDiv);
                }
            });

            // ==========================================
            // SELECT/MOVE TOOL (Fixed + Touch Support)
            // ==========================================
            let selectedAnnotation = null;
            let selectedSvg = null;
            let selectedPageNum = null;
            let copiedAnnotation = null;
            let copiedPageNum = null;
            let isDraggingAnnotation = false;
            let annotationDragStartX = 0;
            let annotationDragStartY = 0;

            // Marquee selection state
            let marqueeActive = false;
            let marqueeStartX = 0, marqueeStartY = 0;
            let marqueeRect = null;
            let marqueeSvg = null;
            let marqueePageNum = null;
            let multiSelectedAnnotations = [];

            // Create selection toolbar for touch devices
            const selectionToolbar = document.createElement('div');
            selectionToolbar.className = 'selection-toolbar';
            selectionToolbar.innerHTML = `
            <button data-action="copy" title="Kopyala (Ctrl+C)">
                <svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                <span>Kopyala</span>
            </button>
            <button data-action="duplicate" title="Çoğalt">
                <svg viewBox="0 0 24 24"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/></svg>
                <span>Çoğalt</span>
            </button>
            <button data-action="delete" class="delete" title="Sil (Del)">
                <svg viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>
                <span>Sil</span>
            </button>
        `;
            document.body.appendChild(selectionToolbar);

            // Selection toolbar event handlers
            selectionToolbar.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (!btn) return;

                const action = btn.dataset.action;
                if (action === 'copy') {
                    copySelectedAnnotation();
                    showToast('Kopyalandı!');
                } else if (action === 'duplicate') {
                    copySelectedAnnotation();
                    pasteAnnotation();
                    showToast('Çoğaltıldı!');
                } else if (action === 'delete') {
                    deleteSelectedAnnotation();
                    showToast('Silindi!');
                }
            });

            function showToast(message) {
                const existingToast = document.querySelector('.toast-notification');
                if (existingToast) existingToast.remove();

                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2000);
            }

            function updateSelectionToolbar() {
                if (selectedAnnotation && currentTool === 'select') {
                    selectionToolbar.classList.add('visible');
                } else {
                    selectionToolbar.classList.remove('visible');
                }
            }

            function clearMultiSelection() {
                if (multiDragHandler) {
                    multiSelectedAnnotations.forEach(el => {
                        el.removeEventListener('mousedown', multiDragHandler);
                        el.removeEventListener('touchstart', multiDragHandler);
                    });
                    multiDragHandler = null;
                }
                multiSelectedAnnotations.forEach(el => {
                    el.classList.remove('annotation-multi-selected');
                    el.style.cursor = '';
                });
                multiSelectedAnnotations = [];
            }

            function clearAnnotationSelection() {
                if (selectedAnnotation) {
                    selectedAnnotation.classList.remove('annotation-selected', 'annotation-dragging', 'just-selected');
                }
                selectedAnnotation = null;
                selectedSvg = null;
                selectedPageNum = null;
                isDraggingAnnotation = false;
                clearMultiSelection();
                updateSelectionToolbar();
            }

            function selectAnnotation(element, svg, pageNum) {
                clearAnnotationSelection();
                selectedAnnotation = element;
                selectedSvg = svg;
                selectedPageNum = pageNum;
                element.classList.add('annotation-selected', 'just-selected');

                // Remove pulse animation after it completes
                setTimeout(() => {
                    element.classList.remove('just-selected');
                }, 600);

                updateSelectionToolbar();
            }

            function deleteSelectedAnnotation() {
                if (multiSelectedAnnotations.length > 0 && marqueeSvg) {
                    // Delete all multi-selected annotations
                    const pageNum = marqueePageNum;
                    multiSelectedAnnotations.forEach(el => el.remove());
                    clearMultiSelection();
                    if (marqueeSvg && marqueeSvg.isConnected) saveAnnotations(pageNum);
                    marqueeSvg = null;
                    marqueePageNum = null;
                } else if (selectedAnnotation && selectedSvg) {
                    selectedAnnotation.remove();
                    saveAnnotations(selectedPageNum);
                    clearAnnotationSelection();
                }
            }

            function copySelectedAnnotation() {
                if (selectedAnnotation) {
                    copiedAnnotation = selectedAnnotation.cloneNode(true);
                    copiedAnnotation.classList.remove('annotation-selected', 'annotation-dragging', 'just-selected');
                    copiedPageNum = selectedPageNum;
                }
            }

            function pasteAnnotation() {
                if (!copiedAnnotation || !pdfViewer) return;

                // Paste to current page
                const currentPage = pdfViewer.currentPageNumber;
                const pageView = pdfViewer.getPageView(currentPage - 1);
                const svg = pageView?.div?.querySelector('.annotationLayer');

                if (svg) {
                    const cloned = copiedAnnotation.cloneNode(true);
                    const offset = 30; // Offset amount for pasted elements

                    // Offset pasted element slightly
                    if (cloned.tagName === 'path') {
                        // For paths, add/update transform translate
                        const currentTransform = cloned.getAttribute('transform') || '';
                        const match = currentTransform.match(/translate\(([^,]+),([^)]+)\)/);
                        let tx = offset, ty = offset;
                        if (match) {
                            tx = parseFloat(match[1]) + offset;
                            ty = parseFloat(match[2]) + offset;
                        }
                        cloned.setAttribute('transform', `translate(${tx}, ${ty})`);
                    } else if (cloned.tagName === 'rect') {
                        cloned.setAttribute('x', parseFloat(cloned.getAttribute('x')) + offset);
                        cloned.setAttribute('y', parseFloat(cloned.getAttribute('y')) + offset);
                    } else if (cloned.tagName === 'ellipse') {
                        cloned.setAttribute('cx', parseFloat(cloned.getAttribute('cx')) + offset);
                        cloned.setAttribute('cy', parseFloat(cloned.getAttribute('cy')) + offset);
                    } else if (cloned.tagName === 'line') {
                        cloned.setAttribute('x1', parseFloat(cloned.getAttribute('x1')) + offset);
                        cloned.setAttribute('y1', parseFloat(cloned.getAttribute('y1')) + offset);
                        cloned.setAttribute('x2', parseFloat(cloned.getAttribute('x2')) + offset);
                        cloned.setAttribute('y2', parseFloat(cloned.getAttribute('y2')) + offset);
                    } else if (cloned.tagName === 'text') {
                        cloned.setAttribute('x', parseFloat(cloned.getAttribute('x')) + offset);
                        cloned.setAttribute('y', parseFloat(cloned.getAttribute('y')) + offset);
                    }

                    svg.appendChild(cloned);
                    saveAnnotations(currentPage);
                    selectAnnotation(cloned, svg, currentPage);
                }
            }

            // Get coordinates from mouse or touch event
            function getEventCoords(e) {
                if (e.touches && e.touches.length > 0) {
                    return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                }
                if (e.changedTouches && e.changedTouches.length > 0) {
                    return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
                }
                return { clientX: e.clientX, clientY: e.clientY };
            }

            // Convert screen coordinates to viewBox coordinates, accounting for CSS rotation
            function screenToViewBox(svg, clientX, clientY) {
                const rect = svg.getBoundingClientRect();
                const vbW = parseFloat(svg.dataset.viewboxWidth);
                const vbH = parseFloat(svg.dataset.viewboxHeight);

                // Offset from center in screen pixels
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const udx = clientX - cx;
                const udy = clientY - cy;

                // Element dimensions (no CSS rotation — PDF.js handles rotation natively)
                let elemW, elemH;
                {
                    elemW = rect.width;
                    elemH = rect.height;
                }

                // Map to viewBox: center-relative to 0,0-relative
                const x = (udx + elemW / 2) * (vbW / elemW);
                const y = (udy + elemH / 2) * (vbH / elemH);

                const scaleX = vbW / elemW;
                const scaleY = vbH / elemH;

                return { x, y, scaleX, scaleY };
            }

            // Convert screen delta (dx,dy pixels) to viewBox delta
            function screenDeltaToViewBox(svg, dxScreen, dyScreen) {
                const rect = svg.getBoundingClientRect();
                const vbW = parseFloat(svg.dataset.viewboxWidth);
                const vbH = parseFloat(svg.dataset.viewboxHeight);

                return {
                    dx: dxScreen * (vbW / rect.width),
                    dy: dyScreen * (vbH / rect.height)
                };
            }

            // Handle select tool events (both mouse and touch)
            function handleSelectPointerDown(e, svg, pageNum) {
                if (currentTool !== 'select') return false;

                const coords = getEventCoords(e);
                const target = e.target;

                if (target === svg || target.tagName === 'svg') {
                    // Clicked on empty area — clear selections and start marquee
                    clearAnnotationSelection();

                    const pt = screenToViewBox(svg, coords.clientX, coords.clientY);

                    marqueeActive = true;
                    marqueeStartX = pt.x;
                    marqueeStartY = pt.y;
                    marqueeSvg = svg;
                    marqueePageNum = pageNum;

                    // Create marquee rectangle
                    marqueeRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    marqueeRect.setAttribute('class', 'marquee-rect');
                    marqueeRect.setAttribute('x', pt.x);
                    marqueeRect.setAttribute('y', pt.y);
                    marqueeRect.setAttribute('width', 0);
                    marqueeRect.setAttribute('height', 0);
                    svg.appendChild(marqueeRect);

                    function onMarqueeMove(ev) {
                        if (!marqueeActive || !marqueeRect) return;
                        ev.preventDefault();

                        const moveCoords = getEventCoords(ev);
                        const mpt = screenToViewBox(marqueeSvg, moveCoords.clientX, moveCoords.clientY);

                        const x = Math.min(marqueeStartX, mpt.x);
                        const y = Math.min(marqueeStartY, mpt.y);
                        const w = Math.abs(mpt.x - marqueeStartX);
                        const h = Math.abs(mpt.y - marqueeStartY);

                        marqueeRect.setAttribute('x', x);
                        marqueeRect.setAttribute('y', y);
                        marqueeRect.setAttribute('width', w);
                        marqueeRect.setAttribute('height', h);
                    }

                    function onMarqueeEnd(ev) {
                        document.removeEventListener('mousemove', onMarqueeMove);
                        document.removeEventListener('mouseup', onMarqueeEnd);
                        document.removeEventListener('touchmove', onMarqueeMove);
                        document.removeEventListener('touchend', onMarqueeEnd);
                        document.removeEventListener('touchcancel', onMarqueeEnd);

                        if (!marqueeRect || !marqueeSvg) { marqueeActive = false; return; }

                        // Marquee bounds
                        const mx = parseFloat(marqueeRect.getAttribute('x'));
                        const my = parseFloat(marqueeRect.getAttribute('y'));
                        const mw = parseFloat(marqueeRect.getAttribute('width'));
                        const mh = parseFloat(marqueeRect.getAttribute('height'));

                        // Remove marquee rectangle
                        marqueeRect.remove();
                        marqueeRect = null;
                        marqueeActive = false;

                        // Ignore tiny marquees (accidental clicks)
                        if (mw < 5 && mh < 5) return;

                        // Find elements intersecting the marquee
                        const elements = marqueeSvg.querySelectorAll('path, rect, ellipse, line, text');
                        multiSelectedAnnotations = [];

                        elements.forEach(el => {
                            // Skip the marquee rect class itself (already removed, but safety)
                            if (el.classList.contains('marquee-rect')) return;

                            const bbox = el.getBBox();
                            let ex = bbox.x, ey = bbox.y;
                            const transform = el.getAttribute('transform');
                            if (transform) {
                                const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                                if (match) { ex += parseFloat(match[1]); ey += parseFloat(match[2]); }
                            }

                            // AABB intersection test
                            if (ex + bbox.width > mx && ex < mx + mw &&
                                ey + bbox.height > my && ey < my + mh) {
                                el.classList.add('annotation-multi-selected');
                                multiSelectedAnnotations.push(el);
                            }
                        });

                        // Enable multi-drag if we selected anything
                        if (multiSelectedAnnotations.length > 0) {
                            setupMultiDrag(marqueeSvg, marqueePageNum);
                        }
                    }

                    document.addEventListener('mousemove', onMarqueeMove, { passive: false });
                    document.addEventListener('mouseup', onMarqueeEnd);
                    document.addEventListener('touchmove', onMarqueeMove, { passive: false });
                    document.addEventListener('touchend', onMarqueeEnd);
                    document.addEventListener('touchcancel', onMarqueeEnd);

                    return true;
                }

                // Check if clicked on an annotation element
                if (target.closest('.annotationLayer') && target !== svg) {
                    e.preventDefault();
                    e.stopPropagation();

                    selectAnnotation(target, svg, pageNum);

                    // Start drag
                    isDraggingAnnotation = true;
                    annotationDragStartX = coords.clientX;
                    annotationDragStartY = coords.clientY;

                    target.classList.add('annotation-dragging');

                    function onMove(ev) {
                        if (!isDraggingAnnotation) return;
                        ev.preventDefault();

                        const moveCoords = getEventCoords(ev);
                        const dxScreen = moveCoords.clientX - annotationDragStartX;
                        const dyScreen = moveCoords.clientY - annotationDragStartY;

                        // Convert screen delta to viewBox delta (rotation-aware)
                        const vbDelta = screenDeltaToViewBox(svg, dxScreen, dyScreen);

                        // Move the element
                        moveAnnotation(target, vbDelta.dx, vbDelta.dy);

                        // Update start position for next move
                        annotationDragStartX = moveCoords.clientX;
                        annotationDragStartY = moveCoords.clientY;
                    }

                    function onEnd(ev) {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('touchend', onEnd);
                        document.removeEventListener('touchcancel', onEnd);

                        target.classList.remove('annotation-dragging');
                        isDraggingAnnotation = false;

                        // Bug fix: Clamp annotation within page bounds to prevent cross-page loss
                        const vbW = parseFloat(svg.dataset.viewboxWidth);
                        const vbH = parseFloat(svg.dataset.viewboxHeight);
                        clampAnnotationToPage(target, vbW, vbH);

                        // Bug fix: Check if SVG is still in DOM before saving
                        if (svg.isConnected) {
                            saveAnnotations(pageNum);
                        }
                    }

                    document.addEventListener('mousemove', onMove, { passive: false });
                    document.addEventListener('mouseup', onEnd);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);

                    return true;
                }

                return false;
            }

            // Multi-drag handler reference for cleanup
            let multiDragHandler = null;

            // Setup multi-drag for marquee-selected annotations
            function setupMultiDrag(svg, pageNum) {
                function startMultiDragHandler(e) {
                    if (currentTool !== 'select') return;
                    e.preventDefault();
                    e.stopPropagation();

                    const startCoords = getEventCoords(e);
                    let lastX = startCoords.clientX;
                    let lastY = startCoords.clientY;

                    multiSelectedAnnotations.forEach(el => el.classList.add('annotation-dragging'));

                    function onMove(ev) {
                        ev.preventDefault();
                        const moveCoords = getEventCoords(ev);
                        const dx = moveCoords.clientX - lastX;
                        const dy = moveCoords.clientY - lastY;
                        const vbDelta = screenDeltaToViewBox(svg, dx, dy);

                        multiSelectedAnnotations.forEach(el => moveAnnotation(el, vbDelta.dx, vbDelta.dy));

                        lastX = moveCoords.clientX;
                        lastY = moveCoords.clientY;
                    }

                    function onEnd() {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onEnd);
                        document.removeEventListener('touchmove', onMove);
                        document.removeEventListener('touchend', onEnd);
                        document.removeEventListener('touchcancel', onEnd);

                        multiSelectedAnnotations.forEach(el => el.classList.remove('annotation-dragging'));

                        // Clamp all selected annotations within page bounds
                        const vbW = parseFloat(svg.dataset.viewboxWidth);
                        const vbH = parseFloat(svg.dataset.viewboxHeight);
                        multiSelectedAnnotations.forEach(el => clampAnnotationToPage(el, vbW, vbH));

                        if (svg.isConnected) saveAnnotations(pageNum);
                    }

                    document.addEventListener('mousemove', onMove, { passive: false });
                    document.addEventListener('mouseup', onEnd);
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onEnd);
                    document.addEventListener('touchcancel', onEnd);
                }

                multiDragHandler = startMultiDragHandler;
                multiSelectedAnnotations.forEach(el => {
                    el.style.cursor = 'grab';
                    el.addEventListener('mousedown', startMultiDragHandler);
                    el.addEventListener('touchstart', startMultiDragHandler, { passive: false });
                });
            }

            // moveAnnotation - applies delta movement to an annotation element
            function moveAnnotation(element, dx, dy) {
                if (element.tagName === 'path') {
                    // Transform path using translate
                    const currentTransform = element.getAttribute('transform') || '';
                    const match = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    let tx = 0, ty = 0;
                    if (match) {
                        tx = parseFloat(match[1]);
                        ty = parseFloat(match[2]);
                    }
                    element.setAttribute('transform', `translate(${tx + dx}, ${ty + dy})`);
                } else if (element.tagName === 'rect') {
                    element.setAttribute('x', parseFloat(element.getAttribute('x')) + dx);
                    element.setAttribute('y', parseFloat(element.getAttribute('y')) + dy);
                } else if (element.tagName === 'ellipse') {
                    element.setAttribute('cx', parseFloat(element.getAttribute('cx')) + dx);
                    element.setAttribute('cy', parseFloat(element.getAttribute('cy')) + dy);
                } else if (element.tagName === 'line') {
                    element.setAttribute('x1', parseFloat(element.getAttribute('x1')) + dx);
                    element.setAttribute('y1', parseFloat(element.getAttribute('y1')) + dy);
                    element.setAttribute('x2', parseFloat(element.getAttribute('x2')) + dx);
                    element.setAttribute('y2', parseFloat(element.getAttribute('y2')) + dy);
                } else if (element.tagName === 'text') {
                    element.setAttribute('x', parseFloat(element.getAttribute('x')) + dx);
                    element.setAttribute('y', parseFloat(element.getAttribute('y')) + dy);
                }
            }

            // Clamp annotation element within page viewBox bounds
            function clampAnnotationToPage(element, maxW, maxH) {
                const margin = 10;
                function clamp(val, min, max) { return Math.max(min, Math.min(val, max)); }

                if (element.tagName === 'path') {
                    const transform = element.getAttribute('transform') || '';
                    const match = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    if (match) {
                        const tx = clamp(parseFloat(match[1]), -maxW + margin, maxW - margin);
                        const ty = clamp(parseFloat(match[2]), -maxH + margin, maxH - margin);
                        element.setAttribute('transform', `translate(${tx}, ${ty})`);
                    }
                } else if (element.tagName === 'rect') {
                    element.setAttribute('x', clamp(parseFloat(element.getAttribute('x')), 0, maxW - margin));
                    element.setAttribute('y', clamp(parseFloat(element.getAttribute('y')), 0, maxH - margin));
                } else if (element.tagName === 'ellipse') {
                    element.setAttribute('cx', clamp(parseFloat(element.getAttribute('cx')), margin, maxW - margin));
                    element.setAttribute('cy', clamp(parseFloat(element.getAttribute('cy')), margin, maxH - margin));
                } else if (element.tagName === 'line') {
                    element.setAttribute('x1', clamp(parseFloat(element.getAttribute('x1')), 0, maxW));
                    element.setAttribute('y1', clamp(parseFloat(element.getAttribute('y1')), 0, maxH));
                    element.setAttribute('x2', clamp(parseFloat(element.getAttribute('x2')), 0, maxW));
                    element.setAttribute('y2', clamp(parseFloat(element.getAttribute('y2')), 0, maxH));
                } else if (element.tagName === 'text') {
                    element.setAttribute('x', clamp(parseFloat(element.getAttribute('x')), 0, maxW - margin));
                    element.setAttribute('y', clamp(parseFloat(element.getAttribute('y')), margin, maxH - margin));
                }
            }

            // Legacy function for backwards compatibility (used elsewhere)
            function handleSelectMouseDown(e, svg, pageNum) {
                return handleSelectPointerDown(e, svg, pageNum);
            }

            // ==========================================
            // KEYBOARD SHORTCUTS
            // ==========================================
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in input
                if (e.target.tagName === 'INPUT' || e.target.contentEditable === 'true') return;

                const key = e.key.toLowerCase();

                // Tool shortcuts
                if (key === 'h') { setTool('highlight'); e.preventDefault(); }
                if (key === 'p') { setTool('pen'); e.preventDefault(); }
                if (key === 'e') { setTool('eraser'); e.preventDefault(); }
                if (key === 't') { setTool('text'); e.preventDefault(); }
                if (key === 'r') { setTool('shape'); e.preventDefault(); }
                if (key === 'v') { setTool('select'); e.preventDefault(); }
                if (key === 'f') { toggleFullscreen(); e.preventDefault(); }

                // Delete selected annotation(s)
                if ((key === 'delete' || key === 'backspace') && (selectedAnnotation || multiSelectedAnnotations.length > 0)) {
                    deleteSelectedAnnotation();
                    e.preventDefault();
                }

                // Undo/Redo
                if ((e.ctrlKey || e.metaKey) && key === 'z' && !e.shiftKey) {
                    performUndo();
                    e.preventDefault();
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && (key === 'y' || (key === 'z' && e.shiftKey))) {
                    performRedo();
                    e.preventDefault();
                    return;
                }

                // Copy/Paste annotations
                if ((e.ctrlKey || e.metaKey) && key === 'c' && selectedAnnotation) {
                    copySelectedAnnotation();
                    e.preventDefault();
                }
                if ((e.ctrlKey || e.metaKey) && key === 'v' && copiedAnnotation) {
                    pasteAnnotation();
                    e.preventDefault();
                }

                // Navigation
                if (key === 's') {
                    document.getElementById('sidebarBtn').click();
                    e.preventDefault();
                }

                // Arrow key navigation
                if (key === 'arrowleft' || key === 'arrowup') {
                    if (pdfViewer && pdfViewer.currentPageNumber > 1) {
                        pdfViewer.currentPageNumber--;
                    }
                    e.preventDefault();
                }
                if (key === 'arrowright' || key === 'arrowdown') {
                    if (pdfViewer && pdfViewer.currentPageNumber < pdfViewer.pagesCount) {
                        pdfViewer.currentPageNumber++;
                    }
                    e.preventDefault();
                }

                // Home/End
                if (key === 'home') {
                    if (pdfViewer) pdfViewer.currentPageNumber = 1;
                    e.preventDefault();
                }
                if (key === 'end') {
                    if (pdfViewer) pdfViewer.currentPageNumber = pdfViewer.pagesCount;
                    e.preventDefault();
                }

                // Zoom shortcuts - prevent browser zoom
                if ((e.ctrlKey || e.metaKey) && (key === '=' || key === '+' || e.code === 'Equal')) {
                    e.preventDefault();
                    e.stopPropagation();
                    pdfViewer.currentScale += 0.25;
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && (key === '-' || e.code === 'Minus')) {
                    e.preventDefault();
                    e.stopPropagation();
                    pdfViewer.currentScale -= 0.25;
                    return;
                }
                if ((e.ctrlKey || e.metaKey) && (key === '0' || e.code === 'Digit0')) {
                    e.preventDefault();
                    e.stopPropagation();
                    pdfViewer.currentScaleValue = 'page-width';
                    return;
                }

                // Escape to deselect tool
                if (key === 'escape') {
                    if (currentTool) {
                        setTool(currentTool); // Toggle off
                    }
                    closeAllDropdowns();
                }

                // Sepia mode
                if (key === 'm') {
                    document.getElementById('sepiaBtn').click();
                    e.preventDefault();
                }
            });

            // ==========================================
            // CONTEXT MENU (Right-click)
            // ==========================================
            const contextMenu = document.createElement('div');
            contextMenu.className = 'contextMenu';
            contextMenu.innerHTML = `
            <div class="contextMenuItem" data-action="highlight">
                <svg viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zM5 16h14l-3-10H8l-3 10z"/></svg>
                Vurgula
                <span class="shortcutHint">H</span>
            </div>
            <div class="contextMenuItem" data-action="pen">
                <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                Kalem
                <span class="shortcutHint">P</span>
            </div>
            <div class="contextMenuItem" data-action="text">
                <svg viewBox="0 0 24 24"><path d="M5 4v3h5.5v12h3V7H19V4H5z"/></svg>
                Metin Ekle
                <span class="shortcutHint">T</span>
            </div>
            <div class="contextMenuDivider"></div>
            <div class="contextMenuItem" data-action="zoomIn">
                <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                Yakınlaştır
                <span class="shortcutHint">Ctrl++</span>
            </div>
            <div class="contextMenuItem" data-action="zoomOut">
                <svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"/></svg>
                Uzaklaştır
                <span class="shortcutHint">Ctrl+-</span>
            </div>
            <div class="contextMenuDivider"></div>
            <div class="contextMenuItem" data-action="sepia">
                <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></svg>
                Okuma Modu
                <span class="shortcutHint">M</span>
            </div>
        `;
            document.body.appendChild(contextMenu);

            // Show context menu on right-click in viewer
            function showCustomContextMenu(e) {
                e.preventDefault();
                contextMenu.style.left = e.clientX + 'px';
                contextMenu.style.top = e.clientY + 'px';
                contextMenu.classList.add('visible');
            }
            container.addEventListener('contextmenu', showCustomContextMenu);

            // Hide context menu on click
            document.addEventListener('click', () => {
                contextMenu.classList.remove('visible');
            });

            // Context menu actions
            contextMenu.addEventListener('click', (e) => {
                const item = e.target.closest('.contextMenuItem');
                if (!item) return;

                const action = item.dataset.action;
                switch (action) {
                    case 'highlight': setTool('highlight'); break;
                    case 'pen': setTool('pen'); break;
                    case 'text': setTool('text'); break;
                    case 'zoomIn': pdfViewer.currentScale += 0.25; break;
                    case 'zoomOut': pdfViewer.currentScale -= 0.25; break;
                    case 'sepia': document.getElementById('sepiaBtn').click(); break;
                }
                contextMenu.classList.remove('visible');
            });

            // ==========================================
            // ERGONOMIC FEATURES
            // ==========================================

            // Fullscreen toggle function (with webkit fallback for iOS Safari)
            function toggleFullscreen() {
                const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
                if (fsEl) {
                    if (document.exitFullscreen) document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                } else {
                    const el = document.documentElement;
                    if (el.requestFullscreen) el.requestFullscreen().catch(() => { });
                    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                }
            }

            // Update fullscreen button icon
            function updateFullscreenIcon() {
                const icon = document.getElementById('fullscreenIcon');
                const btn = document.getElementById('fullscreenBtn');
                const fsEl = document.fullscreenElement || document.webkitFullscreenElement;
                if (fsEl) {
                    icon.innerHTML = '<path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>';
                    btn.classList.add('active');
                } else {
                    icon.innerHTML = '<path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>';
                    btn.classList.remove('active');
                }
            }

            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);

            // Fullscreen button click
            document.getElementById('fullscreenBtn').onclick = () => toggleFullscreen();



            // Mouse wheel zoom with Ctrl
            container.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    if (e.deltaY < 0) {
                        pdfViewer.currentScale += 0.1;
                    } else {
                        pdfViewer.currentScale -= 0.1;
                    }
                }
            }, { passive: false });

            console.log('PDF Viewer Ready');
            console.log('Keyboard Shortcuts: H=Highlight, P=Pen, E=Eraser, T=Text, R=Shapes, S=Sidebar, M=ReadingMode, Arrows=Navigate');

            // ==========================================
            // MOBILE / TABLET SUPPORT
            // ==========================================
            const isMobile = () => window.innerWidth <= 599;
            const isTabletPortrait = () => {
                const w = window.innerWidth;
                return w >= 600 && w <= 1024 && window.innerHeight > window.innerWidth;
            };
            const isTouch = () => 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            // Bottom toolbar element references
            const bottomToolbarInner = document.getElementById('bottomToolbarInner');

            // Elements to move between top toolbar and bottom toolbar on mobile
            // We identify the annotation tools group (highlighter, pen, eraser, select, separator, undo, redo, clearAll, separator, text, shapes)
            const annotationToolsSelector = '#toolbar > .toolbarGroup:nth-child(3)';
            let toolsMovedToBottom = false;
            let annotationToolsPlaceholder = null;

            function setupResponsiveToolbar() {
                const needsBottomBar = isMobile() || isTabletPortrait();

                if (needsBottomBar && !toolsMovedToBottom) {
                    // Move annotation tools to bottom toolbar
                    const annotationGroup = document.querySelector(annotationToolsSelector);
                    if (annotationGroup && bottomToolbarInner) {
                        // Create placeholder to remember position
                        annotationToolsPlaceholder = document.createComment('annotation-tools-placeholder');
                        annotationGroup.parentNode.insertBefore(annotationToolsPlaceholder, annotationGroup);

                        // Move children into bottom toolbar
                        while (annotationGroup.firstChild) {
                            bottomToolbarInner.appendChild(annotationGroup.firstChild);
                        }
                        // Hide empty group
                        annotationGroup.style.display = 'none';
                        toolsMovedToBottom = true;
                    }
                } else if (!needsBottomBar && toolsMovedToBottom) {
                    // Move tools back to top toolbar
                    const annotationGroup = document.querySelector(annotationToolsSelector);
                    if (annotationGroup && bottomToolbarInner && annotationToolsPlaceholder) {
                        while (bottomToolbarInner.firstChild) {
                            annotationGroup.appendChild(bottomToolbarInner.firstChild);
                        }
                        annotationGroup.style.display = '';
                        toolsMovedToBottom = false;
                    }
                }
            }

            // Run on load
            setupResponsiveToolbar();

            // Use matchMedia for responsive switching
            const mobileMediaQuery = window.matchMedia('(max-width: 599px)');
            mobileMediaQuery.addEventListener('change', () => {
                setupResponsiveToolbar();
            });

            const tabletPortraitQuery = window.matchMedia(
                '(min-width: 600px) and (max-width: 1024px) and (orientation: portrait)'
            );
            tabletPortraitQuery.addEventListener('change', () => {
                setupResponsiveToolbar();
            });

            // Also handle resize for orientation changes (debounced)
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(setupResponsiveToolbar, 150);
            });

            // ==========================================
            // PINCH-TO-ZOOM (Touch devices) - Smooth CSS Transform
            // ==========================================
            let pinchStartDistance = 0;
            let pinchStartScale = 1;
            let isPinching = false;
            let pinchMidX = 0;
            let pinchMidY = 0;
            let pinchVisualRatio = 1;

            // The viewer div that holds PDF pages
            const viewerDiv = document.getElementById('viewer');

            function getTouchDistance(touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function getTouchMidpoint(touches) {
                return {
                    x: (touches[0].clientX + touches[1].clientX) / 2,
                    y: (touches[0].clientY + touches[1].clientY) / 2
                };
            }

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    // Cancel any active drawing and clean up
                    if (isDrawing && currentDrawingPage) {
                        if (currentPath && currentPath.parentNode) currentPath.remove();
                        currentPath = null;
                        pathSegments = [];
                        if (drawRAF) { cancelAnimationFrame(drawRAF); drawRAF = null; }
                        isDrawing = false;
                        currentSvg = null;
                        currentDrawingPage = null;
                    }
                    isPinching = true;
                    pinchStartDistance = getTouchDistance(e.touches);
                    pinchStartScale = pdfViewer.currentScale;
                    pinchVisualRatio = 1;

                    // Get midpoint relative to container
                    const mid = getTouchMidpoint(e.touches);
                    const rect = container.getBoundingClientRect();
                    pinchMidX = mid.x - rect.left + container.scrollLeft;
                    pinchMidY = mid.y - rect.top + container.scrollTop;

                    // Prepare for CSS transform - use will-change for GPU acceleration
                    viewerDiv.style.willChange = 'transform';
                    viewerDiv.style.transformOrigin = pinchMidX + 'px ' + pinchMidY + 'px';

                    e.preventDefault();
                }
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (isPinching && e.touches.length === 2) {
                    const dist = getTouchDistance(e.touches);
                    const ratio = dist / pinchStartDistance;
                    // Clamp the target scale
                    const targetScale = pinchStartScale * ratio;
                    const clampedScale = Math.min(Math.max(targetScale, 0.5), 5.0);
                    pinchVisualRatio = clampedScale / pinchStartScale;

                    // Apply CSS transform for instant smooth visual feedback (no re-render)
                    viewerDiv.style.transform = 'scale(' + pinchVisualRatio + ')';

                    e.preventDefault();
                }
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                if (isPinching && e.touches.length < 2) {
                    isPinching = false;

                    // Remove CSS transform
                    viewerDiv.style.transform = '';
                    viewerDiv.style.willChange = '';
                    viewerDiv.style.transformOrigin = '';

                    // Apply actual scale (triggers PDF re-render only once)
                    const finalScale = Math.min(Math.max(pinchStartScale * pinchVisualRatio, 0.5), 5.0);
                    if (Math.abs(finalScale - pdfViewer.currentScale) > 0.01) {
                        pdfViewer.currentScale = finalScale;
                    }
                    pinchVisualRatio = 1;
                }
            });

            container.addEventListener('touchcancel', (e) => {
                if (isPinching) {
                    isPinching = false;
                    viewerDiv.style.transform = '';
                    viewerDiv.style.willChange = '';
                    viewerDiv.style.transformOrigin = '';
                    pinchVisualRatio = 1;
                }
            });

            // ==========================================
            // TOUCH SCROLL BOUNDARY (Prevent exit on tablet)
            // ==========================================
            // On touch devices, prevent scroll from escaping the container
            // when at the top/bottom boundary. Only fullscreen button should exit.
            (function initTouchScrollBoundary() {
                if (!isTouch()) return;

                let touchStartY = 0;

                container.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        touchStartY = e.touches[0].clientY;
                    }
                }, { passive: true });

                container.addEventListener('touchmove', (e) => {
                    // Skip if pinching
                    if (isPinching || e.touches.length !== 1) return;

                    const touchY = e.touches[0].clientY;
                    const deltaY = touchStartY - touchY; // positive = scrolling down

                    const atTop = container.scrollTop <= 0;
                    const atBottom = container.scrollTop + container.clientHeight >= container.scrollHeight - 1;

                    // Prevent overscroll at boundaries
                    if ((atTop && deltaY < 0) || (atBottom && deltaY > 0)) {
                        e.preventDefault();
                    }
                }, { passive: false });
            })();

            // ==========================================
            // CONTEXT MENU TOUCH HANDLING
            // ==========================================
            // On pure touch devices (no fine pointer), don't show custom context menu
            if (isTouch() && !window.matchMedia('(pointer: fine)').matches) {
                container.removeEventListener('contextmenu', showCustomContextMenu);
            }

            // ==========================================
            // SECURITY FEATURES
            // ==========================================

            (function initSecurityFeatures() {
                console.log('[Security] Initializing protection features...');

                // 1. Block dangerous keyboard shortcuts
                document.addEventListener('keydown', function (e) {
                    // Ctrl+S (Save)
                    if (e.ctrlKey && e.key === 's') {
                        e.preventDefault();
                        console.log('[Security] Ctrl+S blocked');
                        return false;
                    }
                    // Ctrl+P (Print)
                    if (e.ctrlKey && e.key === 'p') {
                        e.preventDefault();
                        console.log('[Security] Ctrl+P blocked');
                        return false;
                    }
                    // Ctrl+Shift+S (Save As)
                    if (e.ctrlKey && e.shiftKey && e.key === 'S') {
                        e.preventDefault();
                        return false;
                    }
                    // F12 (DevTools)
                    if (e.key === 'F12') {
                        e.preventDefault();
                        console.log('[Security] F12 blocked');
                        return false;
                    }
                    // Ctrl+Shift+I (DevTools)
                    if (e.ctrlKey && e.shiftKey && e.key === 'I') {
                        e.preventDefault();
                        return false;
                    }
                    // Ctrl+Shift+J (Console)
                    if (e.ctrlKey && e.shiftKey && e.key === 'J') {
                        e.preventDefault();
                        return false;
                    }
                    // Ctrl+U (View Source)
                    if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        return false;
                    }
                    // Ctrl+Shift+C (Inspect Element)
                    if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                        e.preventDefault();
                        return false;
                    }
                }, true);

                // 2. Block context menu (right-click) - EVERYWHERE
                document.addEventListener('contextmenu', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }, true);

                // 3. Block copy/cut/paste
                document.addEventListener('copy', function (e) {
                    e.preventDefault();
                    console.log('[Security] Copy blocked');
                    return false;
                }, true);

                document.addEventListener('cut', function (e) {
                    e.preventDefault();
                    return false;
                }, true);

                // 4. Block drag events (prevent dragging content out)
                document.addEventListener('dragstart', function (e) {
                    e.preventDefault();
                    return false;
                }, true);

                // 5. Block Print via window.print override
                window.print = function () {
                    console.log('[Security] Print function blocked');
                    alert('Yazdırma bu belgede engellenmiştir.');
                    return false;
                };

                // 6. Disable beforeprint event
                window.addEventListener('beforeprint', function (e) {
                    e.preventDefault();
                    document.body.style.display = 'none';
                });

                window.addEventListener('afterprint', function () {
                    document.body.style.display = '';
                });

                // 7. Block screenshot keyboard shortcuts
                document.addEventListener('keyup', function (e) {
                    // PrintScreen key
                    if (e.key === 'PrintScreen') {
                        navigator.clipboard.writeText('');
                        console.log('[Security] PrintScreen clipboard cleared');
                    }
                }, true);

                // 8. Visibility change detection (tab switching for screenshots)
                document.addEventListener('visibilitychange', function () {
                    if (document.hidden) {
                        console.log('[Security] Tab hidden');
                    }
                });

                console.log('[Security] All protection features initialized');
            })();

            // End of main IIFE - pdfDoc, pdfViewer not accessible from console
        })();
    </script>
</body>

</html>